// This document was previously called "DSP_UC_AX1.txt" and "Crazy Taxi.txt"
// CR is set to #FF all the time in this ucode, so srs/lrs always operate on hw registers.

//////////////////////////////////////////////////////////////////////////
// Known addresses in DRAM
Addr	Name				Description/Notes

// Buffers
0x0000						Main Right
0x0140						Main Left
0x0280	
0x0400	
0x0540	
0x0680	
0x07c0	
0x0900	
0x0a40	

0x03c0	update_block		Contains <offset, value> pairs to update current PB with

0x0b80	pb					Current pb, length = 0xc0

0x0e04	ms_remaining		Milliseconds remaining to process for current voice
0x0e05	pUpdate_block		Pointer to update_block
0x0e06	pUpdates_this_ms	Pointer to number of updates

// Pointers to buffers
0x0e08	0x0000				See buffers at 0x0000
0x0e09	0x0140				
0x0e0a	0x0280				
0x0e0b	0x0400				
0x0e0c	0x0540				
0x0e0d	0x0680				
0x0e0e	0x07c0				
0x0e0f	0x0900				
0x0e10	0x0a40				

// Func pointers
0x0e14	selectedMixCtrl		
0x0e15	selectedSRC			
0x0e16	selectedCoef		Points into DROM

// ITD
0x0e40	
0x0e41	
0x0e42	
0x0e43	
//////////////////////////////////////////////////////////////////////////

// Good ol' exception table
0000 0000      nop         
0001 0000      nop                // 0 Reset falls through, kinda wierd...
0002 029f 0c10 jmp         0x0c10 // 1 Stack U/O flow
0004 029f 0c1f jmp         0x0c1f // 2
0006 029f 0c3b jmp         0x0c3b // 3
0008 029f 0c4a jmp         0x0c4a // 4 ? empty
000a 029f 0c50 jmp         0x0c50 // 5 accelerator address overflow
000c 029f 0c82 jmp         0x0c82 // 6 ? empty
000e 029f 0c88 jmp         0x0c88 // 7 ? empty

// Entry point
void Task_Init() {
	// AX operates in this context all the time
	// 0010 1302      sbset       #0x02
	// 0011 1303      sbset       #0x03
	// 0012 1204      sbclr       #0x04
	// 0013 1305      sbset       #0x05
	// 0014 1306      sbset       #0x06
	// 0015 8e00      set16       
	// 0016 8c00      clr15       
	// 0017 8b00      m0          
	// 0018 0092 00ff lri         $CR, #0x00ff
	
	// 001a 8100      clr         $ACC0
	// 001b 8900      clr         $ACC1
	// 001c 009e 0e80 lri         $AC0.M, #0x0e80
	// 001e 00fe 0e1b sr          @0x0e1b, $AC0.M
	// 0020 8100      clr         $ACC0
	// 0021 00fe 0e31 sr          @0x0e31, $AC0.M
	ACC0 = ACC1 = 0
	*0x0e1b = 0xe80 // Used in Cmd8
	*0x0e31 = 0
	
	// Send DSP_INIT mail
	// 0023 16fc dcd1 si          @DMBH, #0xdcd1
	// 0025 16fd 0000 si          @DMBL, #0x0000
	// 0027 16fb 0001 si          @DIRQ, #0x0001
	DMB = 0xdcd10000
	// 0029 26fc      lrs         $AC0.M, @DMBH
	// 002a 02a0 8000 andf        $AC0.M, #0x8000
	// 002c 029c 0029 jlnz        0x0029
	while (@DMBH & 0x8000 == 0);
	
	// 002e 029f 0045 jmp         0x0045
	goto GetNextCmdBlock;
}

void Task_Resume() {
	// Ensure sane context
	// 0030 1302      sbset       #0x02
	// 0031 1303      sbset       #0x03
	// 0032 1204      sbclr       #0x04
	// 0033 1305      sbset       #0x05
	// 0034 1306      sbset       #0x06
	// 0035 8e00      set16       
	// 0036 8c00      clr15       
	// 0037 8b00      m0          
	// 0038 0092 00ff lri         $CR, #0x00ff
	
	// Send DSP_RESUME mail
	// 003a 16fc dcd1 si          @DMBH, #0xdcd1
	// 003c 16fd 0001 si          @DMBL, #0x0001
	// 003e 16fb 0001 si          @DIRQ, #0x0001
	DMB = 0xdcd10001
	// 0040 26fc      lrs         $AC0.M, @DMBH
	// 0041 02a0 8000 andf        $AC0.M, #0x8000
	// 0043 029c 0040 jlnz        0x0040
	while (@DMBH & 0x8000 == 0);
	
GetNextCmdBlock:
	0045 8e00      set16       
	0046 8100      clr         $ACC0
	0047 8900      clr         $ACC1
	0048 009f babe lri         $AC1.M, #0xbabe
	
	// Wait for 0xbabexxxx mail from cpu
	do {
	// 004a 26fe      lrs         $AC0.M, @CMBH
	// 004b 02c0 8000 andcf       $AC0.M, #0x8000
	// 004d 029c 004a jlnz        0x004a
		while (@CMBH & 0x8000 == 0);
	
	// 004f 8200      cmp         
	// 0050 0294 004a jnz         0x004a
	} while (@CMBH != 0xbabe);
	
	// Save the low 16bits of the mail
	// 0052 23ff      lrs         $AX1.H, @CMBL
	u16 length = @CMBL
	
	// Get next mail
	// 0053 8100      clr         $ACC0
	// 0054 26fe      lrs         $AC0.M, @CMBH
	// 0055 02c0 8000 andcf       $AC0.M, #0x8000
	// 0057 029c 0054 jlnz        0x0054
	while (@CMBH & 0x8000 == 0);
	
	// 0059 27ff      lrs         $AC1.M, @CMBL
	// 005a 0240 7fff andi        $AC0.M, #0x7fff
	// 005c 2ece      srs         @DSMAH, $AC0.M
	// 005d 2fcf      srs         @DSMAL, $AC1.M
	// 005e 16cd 0c00 si          @DSPA, #0x0c00
	// 0060 8100      clr         $ACC0
	// 0061 2ec9      srs         @DSCR, $AC0.M
	// 0062 1ffb      mrr         $AC1.M, $AX1.H
	// 0063 2fcb      srs         @DSBL, $AC1.M
	// DMA in the CmdBlock
	static u16* CmdBlockBuf = 0x0c00
	DSMA = (@CMBH & ~0x8000) << 16 | @CMBL
	DSPA = CmdBlockBuf
	DSCR = 0 // CPU -> DMEM
	DSBL = length
	
	// 0064 02bf 055c call        0x055c
	WaitDMA();
	
	// Init the CmdBlock pointer
	0066 0080 0c00 lri         $AR0, #0x0c00

DoNextCommand:
	// 0068 8e00      set16       
	// 0069 8100      clr         $ACC0
	// 006a 8970      clr'l       $ACC1 : $AC0.M, @$AR0
	// 006b b100      tst         $ACC0
	// 006c 0291 007e jl          0x007e
	u16 Cmd = *(CmdBlockBuf++)
	if (Cmd < 0) // How could this be possible? 'l is 16bit load...
		Die_InvalidCmd();
	
	// 006e 0a12      lris        $AX0.H, #0x12
	// 006f c100      cmpar       $ACC0, $AX0.H
	// 0070 0292 007e jg          0x007e
	if (Cmd > 0x12)
		Die_InvalidCmd();
	
	// 0072 009f 0aff lri         $AC1.M, #0x0aff
	// 0074 4c00      add         $ACC0, $ACC1
	// 0075 1c7e      mrr         $AR3, $AC0.M
	// 0076 0213      ilrr        $AC0.M, @$AR3
	// 0077 1c7e      mrr         $AR3, $AC0.M
	// 0078 176f      jmpr        $AR3
	switch (Cmd) {
	case 0: Cmd_0(); break; // 0082
	case 1: Cmd_1(); break; // 013e
	case 2: Cmd_2(); break; // 01bc
	case 3: Cmd_3(); break; // 0248
	case 4: Cmd_4(); break; // 0413
	case 5: Cmd_5(); break; // 0427
	case 6: Cmd_6(); break; // 0165
	case 7: Cmd_7(); break; // 0574
	case 8: Cmd_8(); break; // 0b37
	case 9: Cmd_9(); break; // 015f
	case 0xa: Cmd_a(); break; // 0478
	case 0xb: Cmd_b(); break; // 0474
	case 0xc: Cmd_c(); break; // 0476
	case 0xd: Cmd_d(); break; // 01a9
	case 0xe: Cmd_e(); break; // 043b
	case 0xf: Cmd_f(); break; // 047a
	case 0x10: Cmd_10(); break; // 0bb1
	case 0x11: Cmd_11(); break; // 0175
	}

	// Somehow we've passed the cmd proccessor; DIE!!
	// 0079 16fc fbad si          @DMBH, #0xfbad
	// 007b 16fd 8080 si          @DMBL, #0x8080
	DMB = 0xfbad8080
	007d 0021      halt        
}

// Die and conveniently tell the cpu which cmd was baad
void Die_InvalidCmd() {
	007e 16fc baad si          @DMBH, #0xbaad
	0080 2efd      srs         @DMBL, $AC0.M
	0081 0021      halt        
}

// Executes the same operation 3 times on buffers: (0, 0x0400, 0x07c0)
void Cmd_0() {
	// 0082 8100      clr         $ACC0
	// 0083 8970      clr'l       $ACC1 : $AC0.M, @$AR0
	// 0084 8e78      set16'l     : $AC1.M, @$AR0
	u16 maddrh = *(CmdBlockBuf++)
	u16 maddrl = *(CmdBlockBuf++)
	
	// 0085 2ece      srs         @DSMAH, $AC0.M
	// 0086 2fcf      srs         @DSMAL, $AC1.M
	// 0087 009e 0e44 lri         $AC0.M, #0x0e44
	// 0089 2ecd      srs         @DSPA, $AC0.M
	// 008a 0e00      lris        $AC0.M, #0x00
	// 008b 2ec9      srs         @DSCR, $AC0.M
	// 008c 009e 0040 lri         $AC0.M, #0x0040
	// 008e 2ecb      srs         @DSBL, $AC0.M
	
	// DMA 0x0040bytes to DRAM @ 0x0e44 from CPU @ maddr
	
	008f 0081 0e44 lri         $AR1, #0x0e44 // source
	0091 0082 0000 lri         $AR2, #0x0000 // destination
	
	0093 009b 009f lri         $AX1.H, #0x009f
	0095 009a 0140 lri         $AX0.H, #0x0140 // loop length if !ACC0
	
	0097 8100      clr         $ACC0
	0098 8900      clr         $ACC1
	
	0099 8f00      set40       
	
	// 009a 02bf 055c call        0x055c
	WaitDMA();
	
	009c 193e      lrri        $AC0.M, @$AR1
	009d 193c      lrri        $AC0.L, @$AR1
	009e b100      tst         $ACC0
	009f 193f      lrri        $AC1.M, @$AR1 // added to ACC0 in confusing ways
	// 00a0 0294 00a6 jnz         0x00a6
	if (!$ACC0) {
		00a2 005a      loop        $AX0.H
			00a3 1b5e      srri        @$AR2, $AC0.M
			
	// 00a4 029f 00ae jmp         0x00ae
	} else {
		00a6 9900      asr16       $ACC1
		00a7 1b5e      srri        @$AR2, $AC0.M
		00a8 1b5c      srri        @$AR2, $AC0.L
		00a9 007b 00ad bloop       $AX1.H, 0x00ad
			00ab 4c00      add         $ACC0, $ACC1
			00ac 1b5e      srri        @$AR2, $AC0.M
			00ad 1b5c      srri        @$AR2, $AC0.L
			
	}
	
	// same code block as above...epic fail?
	00ae 193e      lrri        $AC0.M, @$AR1
	00af 193c      lrri        $AC0.L, @$AR1
	00b0 b100      tst         $ACC0
	00b1 193f      lrri        $AC1.M, @$AR1
	// 00b2 0294 00b8 jnz         0x00b8
	if (!$ACC0) {
		00b4 005a      loop        $AX0.H
			00b5 1b5e      srri        @$AR2, $AC0.M
			
	// 00b6 029f 00c0 jmp         0x00c0
	} else {
		00b8 9900      asr16       $ACC1
		00b9 1b5e      srri        @$AR2, $AC0.M
		00ba 1b5c      srri        @$AR2, $AC0.L
		00bb 007b 00bf bloop       $AX1.H, 0x00bf
			00bd 4c00      add         $ACC0, $ACC1
			00be 1b5e      srri        @$AR2, $AC0.M
			00bf 1b5c      srri        @$AR2, $AC0.L
			
	}
	
	// ...and again! wtf
	00c0 193e      lrri        $AC0.M, @$AR1
	00c1 193c      lrri        $AC0.L, @$AR1
	00c2 b100      tst         $ACC0
	00c3 193f      lrri        $AC1.M, @$AR1
	// 00c4 0294 00ca jnz         0x00ca
	if (!$ACC0) {
		00c6 005a      loop        $AX0.H
			00c7 1b5e      srri        @$AR2, $AC0.M
			
	// 00c8 029f 00d2 jmp         0x00d2
	} else {
		00ca 9900      asr16       $ACC1
		00cb 1b5e      srri        @$AR2, $AC0.M
		00cc 1b5c      srri        @$AR2, $AC0.L
		00cd 007b 00d1 bloop       $AX1.H, 0x00d1
			00cf 4c00      add         $ACC0, $ACC1
			00d0 1b5e      srri        @$AR2, $AC0.M
			00d1 1b5c      srri        @$AR2, $AC0.L
			
	}
	
	// set to next buffer
	00d2 0082 0400 lri         $AR2, #0x0400
	
	// same code block, uses tst'l in one place...otherwise the same
	00d4 193e      lrri        $AC0.M, @$AR1
	00d5 193c      lrri        $AC0.L, @$AR1
	00d6 b179      tst'l       $ACC0 : $AC1.M, @$AR1
	// 00d7 0294 00dd jnz         0x00dd
	if (!$ACC0) {
		00d9 005a      loop        $AX0.H
			00da 1b5e      srri        @$AR2, $AC0.M
	// 00db 029f 00e5 jmp         0x00e5
	} else {
		00dd 9900      asr16       $ACC1
		00de 1b5e      srri        @$AR2, $AC0.M
		00df 1b5c      srri        @$AR2, $AC0.L
		00e0 007b 00e4 bloop       $AX1.H, 0x00e4
			00e2 4c00      add         $ACC0, $ACC1
			00e3 1b5e      srri        @$AR2, $AC0.M
			00e4 1b5c      srri        @$AR2, $AC0.L
	}
	
	// same code block, using tst'l again...wonder if it actually changes behavior?
	00e5 193e      lrri        $AC0.M, @$AR1
	00e6 193c      lrri        $AC0.L, @$AR1
	00e7 b179      tst'l       $ACC0 : $AC1.M, @$AR1
	// 00e8 0294 00ee jnz         0x00ee
	if (!$ACC0) {
		00ea 005a      loop        $AX0.H
			00eb 1b5e      srri        @$AR2, $AC0.M
	// 00ec 029f 00f6 jmp         0x00f6
	} else {
		00ee 9900      asr16       $ACC1
		00ef 1b5e      srri        @$AR2, $AC0.M
		00f0 1b5c      srri        @$AR2, $AC0.L
		00f1 007b 00f5 bloop       $AX1.H, 0x00f5
			00f3 4c00      add         $ACC0, $ACC1
			00f4 1b5e      srri        @$AR2, $AC0.M
			00f5 1b5c      srri        @$AR2, $AC0.L
	}
	
	// see comments above
	00f6 193e      lrri        $AC0.M, @$AR1
	00f7 193c      lrri        $AC0.L, @$AR1
	00f8 b179      tst'l       $ACC0 : $AC1.M, @$AR1
	// 00f9 0294 00ff jnz         0x00ff
	if (!$ACC0) {
		00fb 005a      loop        $AX0.H
			00fc 1b5e      srri        @$AR2, $AC0.M
	// 00fd 029f 0107 jmp         0x0107
	} else {
		00ff 9900      asr16       $ACC1
		0100 1b5e      srri        @$AR2, $AC0.M
		0101 1b5c      srri        @$AR2, $AC0.L
		0102 007b 0106 bloop       $AX1.H, 0x0106
			0104 4c00      add         $ACC0, $ACC1
			0105 1b5e      srri        @$AR2, $AC0.M
			0106 1b5c      srri        @$AR2, $AC0.L
	}
	
	// set to next buffer
	0107 0082 07c0 lri         $AR2, #0x07c0
	
	// see comments above
	0109 193e      lrri        $AC0.M, @$AR1
	010a 193c      lrri        $AC0.L, @$AR1
	010b b179      tst'l       $ACC0 : $AC1.M, @$AR1
	// 010c 0294 0112 jnz         0x0112
	if (!$ACC0) {
		010e 005a      loop        $AX0.H
			010f 1b5e      srri        @$AR2, $AC0.M
	// 0110 029f 011a jmp         0x011a
	} else {
		0112 9900      asr16       $ACC1
		0113 1b5e      srri        @$AR2, $AC0.M
		0114 1b5c      srri        @$AR2, $AC0.L
		0115 007b 0119 bloop       $AX1.H, 0x0119
			0117 4c00      add         $ACC0, $ACC1
			0118 1b5e      srri        @$AR2, $AC0.M
			0119 1b5c      srri        @$AR2, $AC0.L
	}
	
	// see comments above
	011a 193e      lrri        $AC0.M, @$AR1
	011b 193c      lrri        $AC0.L, @$AR1
	011c b179      tst'l       $ACC0 : $AC1.M, @$AR1
	// 011d 0294 0123 jnz         0x0123
	if (!$ACC0) {
		011f 005a      loop        $AX0.H
			0120 1b5e      srri        @$AR2, $AC0.M
	// 0121 029f 012b jmp         0x012b
	} else {
		0123 9900      asr16       $ACC1
		0124 1b5e      srri        @$AR2, $AC0.M
		0125 1b5c      srri        @$AR2, $AC0.L
		0126 007b 012a bloop       $AX1.H, 0x012a
			0128 4c00      add         $ACC0, $ACC1
			0129 1b5e      srri        @$AR2, $AC0.M
			012a 1b5c      srri        @$AR2, $AC0.L
	}
	
	// see comments above
	012b 193e      lrri        $AC0.M, @$AR1
	012c 193c      lrri        $AC0.L, @$AR1
	012d b179      tst'l       $ACC0 : $AC1.M, @$AR1
	// 012e 0294 0134 jnz         0x0134
	if (!$ACC0) {
		0130 005a      loop        $AX0.H
			0131 1b5e      srri        @$AR2, $AC0.M
	// 0132 029f 013c jmp         0x013c
	} else {
		0134 9900      asr16       $ACC1
		0135 1b5e      srri        @$AR2, $AC0.M
		0136 1b5c      srri        @$AR2, $AC0.L
		0137 007b 013b bloop       $AX1.H, 0x013b
			0139 4c00      add         $ACC0, $ACC1
			013a 1b5e      srri        @$AR2, $AC0.M
			013b 1b5c      srri        @$AR2, $AC0.L
	}
	
	// 013c 029f 0068 jmp         0x0068
	goto DoNextCommand;
}

void Cmd_1() {
	013e 0085 ffff lri         $IX1, #0xffff // -1
	
	// 0140 8150      clr'l       $ACC0 : $AX0.H, @$AR0
	// 0141 8940      clr'l       $ACC1 : $AX0.L, @$AR0
	// 0142 8e48      set16'l     : $AX1.L, @$AR0
	// 0143 00fa 0e17 sr          @0x0e17, $AX0.H
	// 0145 00f8 0e18 sr          @0x0e18, $AX0.L
	// 0147 0081 0000 lri         $AR1, #0x0000
	// 0149 02bf 04f1 call        0x04f1
	u16 maddrh = *(CmdBlockBuf++)
	u16 maddrl = *(CmdBlockBuf++)
	u16 unkForMulBuffer1 = *(CmdBlockBuf++)
	u16 unkForMulBuffer2 = 0 // a buffer in dram
	Unk(maddrh << 16 | maddrl, unkForMulBuffer1, unkForMulBuffer2)
	
	// 014b 00da 0e17 lr          $AX0.H, @0x0e17
	// 014d 00d8 0e18 lr          $AX0.L, @0x0e18
	// 014f 8948      clr'l       $ACC1 : $AX1.L, @$AR0
	// 0150 0081 0400 lri         $AR1, #0x0400
	// 0152 02bf 04f1 call        0x04f1
	unkForMulBuffer1 = *(CmdBlockBuf++)
	unkForMulBuffer2 = 0x0400
	Unk(maddrh << 16 | maddrl, unkForMulBuffer1, unkForMulBuffer2)
	
	// 0154 00da 0e17 lr          $AX0.H, @0x0e17
	// 0156 00d8 0e18 lr          $AX0.L, @0x0e18
	// 0158 8948      clr'l       $ACC1 : $AX1.L, @$AR0
	// 0159 0081 07c0 lri         $AR1, #0x07c0
	// 015b 02bf 04f1 call        0x04f1
	unkForMulBuffer1 = *(CmdBlockBuf++)
	unkForMulBuffer2 = 0x07c0
	Unk(maddrh << 16 | maddrl, unkForMulBuffer1, unkForMulBuffer2)
	
	// 015d 029f 0068 jmp         0x0068
	goto DoNextCommand;
}

void Cmd_9() {
	015f 0086 07c0 lri         $IX2, #0x07c0 // often used buffer in dram
	
	0161 02bf 0484 call        0x0484
	
	// 0163 029f 0068 jmp         0x0068
	goto DoNextCommand;
}

void Cmd_6() {
	0165 8100      clr         $ACC0
	0166 8e00      set16       
	
	// 0167 191e      lrri        $AC0.M, @$AR0
	// 0168 191c      lrri        $AC0.L, @$AR0
	u16 maddrh = *(CmdBlockBuf++)
	u16 maddrl = *(CmdBlockBuf++)
	
	// 0169 2ece      srs         @DSMAH, $AC0.M
	// 016a 2ccf      srs         @DSMAL, $AC0.L
	// 016b 16cd 0000 si          @DSPA, #0x0000
	// 016d 16c9 0001 si          @DSCR, #0x0001
	// 016f 16cb 0780 si          @DSBL, #0x0780
	
	// DMA 0x780bytes to CPU @ maddr from DMEM @ 0
	
	// 0171 02bf 055c call        0x055c
	WaitDMA();
	
	// 0173 029f 0068 jmp         0x0068
	goto DoNextCommand;
}

void Cmd_11() {
	// 0175 8100      clr         $ACC0
	// 0176 8970      clr'l       $ACC1 : $AC0.M, @$AR0
	// 0177 8e60      set16'l     : $AC0.L, @$AR0
	u16 maddrh = *(CmdBlockBuf++)
	u16 maddrl = *(CmdBlockBuf++)
	
	// 0178 2ece      srs         @DSMAH, $AC0.M
	// 0179 2ccf      srs         @DSMAL, $AC0.L
	// 017a 16cd 0e44 si          @DSPA, #0x0e44
	// 017c 16c9 0000 si          @DSCR, #0x0000
	// 017e 8900      clr         $ACC1
	// 017f 0d20      lris        $AC1.L, #0x20
	// 0180 2dcb      srs         @DSBL, $AC1.L
	
	// DMA 0x20bytes to DRAM @ 0x0e44 from CPU @ maddr
	
	u16 length_of_0e44 = 0x20
	
	// 0181 4c00      add         $ACC0, $ACC1
	maddr += length_of_0e44
	
	// Save CmdBlockBuf
	// 0182 1c80      mrr         $IX0, $AR0
	
	// 0183 0080 0280 lri         $AR0, #0x0280
	// 0185 0081 0000 lri         $AR1, #0x0000
	// 0187 0082 0140 lri         $AR2, #0x0140
	// 0189 0083 0e44 lri         $AR3, #0x0e44
	// 018b 0a00      lris        $AX0.H, #0x00
	
	// 018c 27c9      lrs         $AC1.M, @DSCR
	// 018d 03a0 0004 andf        $AC1.M, #0x0004
	// 018f 029c 018c jlnz        0x018c
	while (@DSCR & 4);
	
	// 0191 2ece      srs         @DSMAH, $AC0.M
	// 0192 2ccf      srs         @DSMAL, $AC0.L
	// 0193 16cd 0e54 si          @DSPA, #0x0e54
	// 0195 16c9 0000 si          @DSCR, #0x0000
	// 0197 16cb 0260 si          @DSBL, #0x0260
	
	// DMA 0x0260bytes to DRAM @ 0x0e54 from CPU @ maddr
	
	// 0199 009f 00a0 lri         $AC1.M, #0x00a0
	// 019b 8f00      set40       
	// 019c 007f 01a5 bloop       $AC1.M, 0x01a5
	// 	019e 197e      lrri        $AC0.M, @$AR3
	// 	019f 1b1a      srri        @$AR0, $AX0.H
	// 	01a0 197c      lrri        $AC0.L, @$AR3
	// 	01a1 1b1a      srri        @$AR0, $AX0.H
	// 	01a2 1b5e      srri        @$AR2, $AC0.M
	// 	01a3 7c22      neg's       $ACC0 : @$AR2, $AC0.L
	// 	01a4 1b3e      srri        @$AR1, $AC0.M
	// 	01a5 1b3c      srri        @$AR1, $AC0.L
		
	// high reg will only be sign bits, and it's never stored, so we can use s32 here
	s32* buffer_source = 0x0e44
	s32* buffer_dest = 0x0140
	s32* buffer_to_zero = 0x0280
	s32* buffer_dest_neg = 0x0000
	for (i = 0x00a0; i > 0; i--) {
		s32 thing = *(buffer_source++)
		*(buffer_to_zero++) = 0
		*(buffer_dest++) = thing
		*(buffer_dest_neg++) = ~thing
	}
	
	// Restore CmdBlockBuf
	01a6 1c04      mrr         $AR0, $IX0
	
	// 01a7 029f 0068 jmp         0x0068
	goto DoNextCommand;
}

// Interesting, DMAs in new CmdBlock and starts executing it
void Cmd_D() {
	// 01a9 8e70      set16'l     : $AC0.M, @$AR0
	// 01aa 8960      clr'l       $ACC1 : $AC0.L, @$AR0
	u16 maddrh = *(CmdBlockBuf++)
	u16 maddrl = *(CmdBlockBuf++)
	
	// 01ab 191f      lrri        $AC1.M, @$AR0
	u16 numbytes = *(CmdBlockBuf++)

	// 01ac 2ece      srs         @DSMAH, $AC0.M
	// 01ad 2ccf      srs         @DSMAL, $AC0.L
	// 01ae 16cd 0c00 si          @DSPA, #0x0c00
	// 01b0 16c9 0000 si          @DSCR, #0x0000
	// 01b2 0503      addis       $AC1.M, #0x03
	// 01b3 0340 fff0 andi        $AC1.M, #0xfff0
	// 01b5 2fcb      srs         @DSBL, $AC1.M
	
	// DMA ((numbytes + 3) & 0xfff0)bytes to DMEM @ 0x0c00 from CPU @ maddr
	
	// 01b6 02bf 055c call        0x055c
	WaitDMA();
	
	// 01b8 0080 0c00 lri         $AR0, #0x0c00
	CmdBlockBuf = 0x0c00
	
	// 01ba 029f 0068 jmp         0x0068
	goto DoNextCommand;
}

// DMAs in a new PB and inits values (itd, func pointers, etc)
// DMAs in new update_block, but doesn't apply it
void Cmd_2() {
	01bc 8100      clr         $ACC0
	
	// 01bd 8970      clr'l       $ACC1 : $AC0.M, @$AR0
	// 01be 8e78      set16'l     : $AC1.M, @$AR0
	u16 maddrh = *(CmdBlockBuf++)
	u16 maddrl = *(CmdBlockBuf++)
	
	// 01bf 2ece      srs         @DSMAH, $AC0.M
	// 01c0 2fcf      srs         @DSMAL, $AC1.M
	// 01c1 16cd 0b80 si          @DSPA, #0x0b80
	// 01c3 16c9 0000 si          @DSCR, #0x0000
	// 01c5 16cb 00c0 si          @DSBL, #0x00c0
	
	// DMA 0x00c0bytes to DMEM @ 0x0b80 from CPU @ maddr
	
	// 01c7 0082 0e08 lri         $AR2, #0x0e08
	// 01c9 009f 0000 lri         $AC1.M, #0x0000
	// 01cb 1b5f      srri        @$AR2, $AC1.M
	// 01cc 009f 0140 lri         $AC1.M, #0x0140
	// 01ce 1b5f      srri        @$AR2, $AC1.M
	// 01cf 009f 0280 lri         $AC1.M, #0x0280
	// 01d1 1b5f      srri        @$AR2, $AC1.M
	// 01d2 009f 0400 lri         $AC1.M, #0x0400
	// 01d4 1b5f      srri        @$AR2, $AC1.M
	// 01d5 009f 0540 lri         $AC1.M, #0x0540
	// 01d7 1b5f      srri        @$AR2, $AC1.M
	// 01d8 009f 0680 lri         $AC1.M, #0x0680
	// 01da 1b5f      srri        @$AR2, $AC1.M
	// 01db 009f 07c0 lri         $AC1.M, #0x07c0
	// 01dd 1b5f      srri        @$AR2, $AC1.M
	// 01de 009f 0900 lri         $AC1.M, #0x0900
	// 01e0 1b5f      srri        @$AR2, $AC1.M
	// 01e1 009f 0a40 lri         $AC1.M, #0x0a40
	// 01e3 1b5f      srri        @$AR2, $AC1.M
	*0x0e08 = 0x0000
	*0x0e09 = 0x0140
	*0x0e0a = 0x0280
	*0x0e0b = 0x0400
	*0x0e0c = 0x0540
	*0x0e0d = 0x0680
	*0x0e0e = 0x07c0
	*0x0e0f = 0x0900
	*0x0e10 = 0x0a40
	
	// 01e4 02bf 055c call        0x055c
	WaitDMA();
	
	// 01e6 00de 0ba7 lr          $AC0.M, @0x0ba7
	// 01e8 00df 0ba8 lr          $AC1.M, @0x0ba8
	// 01ea 2ece      srs         @DSMAH, $AC0.M
	// 01eb 2fcf      srs         @DSMAL, $AC1.M
	// 01ec 16cd 03c0 si          @DSPA, #0x03c0
	// 01ee 16c9 0000 si          @DSCR, #0x0000
	// 01f0 16cb 0080 si          @DSBL, #0x0080
	
	// DMA 0x80bytes from CPU @ ((pb.update.dataHi << 16) | pb.update.dataLo) to DRAM @ 0x03c0
	
	// 01f2 8100      clr         $ACC0
	// 01f3 8900      clr         $ACC1
	
	// 01f4 00de 0b84 lr          $AC0.M, @0x0b84
	// 01f6 009f 0b31 lri         $AC1.M, #0x0b31
	// 01f8 4c00      add         $ACC0, $ACC1
	// 01f9 1c7e      mrr         $AR3, $AC0.M
	// 01fa 0213      ilrr        $AC0.M, @$AR3
	// 01fb 00fe 0e15 sr          @0x0e15, $AC0.M
	*0x0e15 = *(0x0b31 + pb.srcSelect) // func ptr for src
	
	// 01fd 00de 0b85 lr          $AC0.M, @0x0b85
	// 01ff 009f 0b34 lri         $AC1.M, #0x0b34
	// 0201 4c00      add         $ACC0, $ACC1
	// 0202 1c7e      mrr         $AR3, $AC0.M
	// 0203 0213      ilrr        $AC0.M, @$AR3
	// 0204 00fe 0e16 sr          @0x0e16, $AC0.M
	*0x0e16 = *(0x0b34 + pb.coefSelect) // ptr to coef table
	
	// 0206 00de 0b86 lr          $AC0.M, @0x0b86
	// 0208 009f 0b11 lri         $AC1.M, #0x0b11
	// 020a 4c00      add         $ACC0, $ACC1
	// 020b 1c7e      mrr         $AR3, $AC0.M
	// 020c 0213      ilrr        $AC0.M, @$AR3
	// 020d 00fe 0e14 sr          @0x0e14, $AC0.M
	*0x0e14 = *(0x0b11 + pb.mixerCtrl) // func ptr for mixer
	
	// 020f 8100      clr         $ACC0
	// 0210 00de 0b9b lr          $AC0.M, @0x0b9b
	// 0212 b100      tst         $ACC0
	// 0213 0295 023a jz          0x023a
	if (pb.itd.flag != AX_PB_ITD_OFF) {
		// 0215 8900      clr         $ACC1
		// 0216 00df 0b9e lr          $AC1.M, @0x0b9e
		// 0218 0300 0cc0 addi        $AC1.M, #0x0cc0
		// 021a 00ff 0e40 sr          @0x0e40, $AC1.M
		*0x0e40 = 0x0cc0 + pb.itd.shiftL
		
		// 021c 00df 0b9f lr          $AC1.M, @0x0b9f
		// 021e 0300 0cc0 addi        $AC1.M, #0x0cc0
		// 0220 00ff 0e41 sr          @0x0e41, $AC1.M
		*0x0e41 = 0x0cc0 + pb.itd.shiftR
		
		// 0222 009f 0ce0 lri         $AC1.M, #0x0ce0
		// 0224 00ff 0e42 sr          @0x0e42, $AC1.M
		// 0226 00ff 0e43 sr          @0x0e43, $AC1.M
		*0x0e42 = 0x0ce0
		*0x0e43 = 0x0ce0
		
		// 0228 02bf 055c call        0x055c
		WaitDMA();
		
		// 022a 00de 0b9c lr          $AC0.M, @0x0b9c
		// 022c 2ece      srs         @DSMAH, $AC0.M
		// 022d 00de 0b9d lr          $AC0.M, @0x0b9d
		// 022f 2ecf      srs         @DSMAL, $AC0.M
		// 0230 16cd 0cc0 si          @DSPA, #0x0cc0
		// 0232 16c9 0000 si          @DSCR, #0x0000
		// 0234 16cb 0040 si          @DSBL, #0x0040
		
		// DMA 0x0040bytes to DMEM @ 0x0cc0 from CPU @ (pb.itd.bufferHi << 16) | pb.itd.bufferLo
		
		// 0236 02bf 055c call        0x055c
		WaitDMA();
		
		// 0238 029f 0068 jmp         0x0068
		goto DoNextCommand;

	} else {
	
		// 023a 009f 0ce0 lri         $AC1.M, #0x0ce0
		// 023c 00ff 0e42 sr          @0x0e42, $AC1.M
		// 023e 00ff 0e40 sr          @0x0e40, $AC1.M
		// 0240 00ff 0e41 sr          @0x0e41, $AC1.M
		// 0242 00ff 0e43 sr          @0x0e43, $AC1.M
		*0x0e42 = 0x0ce0
		*0x0e40 = 0x0ce0
		*0x0e41 = 0x0ce0
		*0x0e43 = 0x0ce0
		
		// 0244 02bf 055c call        0x055c
		WaitDMA();
		
		// 0246 029f 0068 jmp         0x0068
		goto DoNextCommand;
	}
}

// Function calls itself until there are no more linked PBs
void Cmd_3() {
	0248 8e00      set16       
	
	// Save CmdBlockBuf ptr
	0249 00e0 0e07 sr          @0x0e07, $AR0
	
	// Processes pb.update.updNum[0] to pb.update.updNum[5]
	// Applies specified number of updates for every millisecond of voice frame (5 millisecs)
	// first millisec's updates are ignored <- not proven, yet
	
	// 024b 0080 0ba2 lri         $AR0, #0x0ba2 // pb.update.updNum[0]
	// 024d 0081 03c0 lri         $AR1, #0x03c0
	// 024f 0e05      lris        $AC0.M, #0x05
	// 0250 00fe 0e04 sr          @0x0e04, $AC0.M // counter to decrement
	// 0252 8900      clr         $ACC1
	u16* pUpdates_this_ms = 0x0ba2
	u16* pUpdate_block = 0x03c0
	u16 ms_remaining = 5

NextMillisecUpd:
	// 0253 8150      clr'l       $ACC0 : $AX0.H, @$AR0
	// 0254 009f 0b80 lri         $AC1.M, #0x0b80
	// 0256 007a 025b bloop       $AX0.H, 0x025b
		// 0258 193e      lrri        $AC0.M, @$AR1
		// 0259 4c49      add'l       $ACC0, $ACC1 : $AX1.L, @$AR1
		// 025a 1c5e      mrr         $AR2, $AC0.M
		// 025b 1a59      srr         @$AR2, $AX1.L // AR2 isn't changed till updates are done

	// Write updates from update_block to pb in dram
	for (int i = 0; i < *pUpdates_this_ms; i+=2) {
		// Looks like 0x03c0 is a struct of <offset, value> pairs to write into PB
		*(0x0b80 + *(pUpdate_block + i)) = *(pUpdate_block + i + 1)
	}
	pUpdates_this_ms++

	// 025c 0083 0e05 lri         $AR3, #0x0e05
	// 025e 1b61      srri        @$AR3, $AR1
	// 025f 1b60      srri        @$AR3, $AR0
	*0x0e05 = pUpdate_block
	*0x0e06 = pUpdates_this_ms
	// They are restored before jmping back to NextMillisecUpd
	
	// 0260 00de 0b87 lr          $AC0.M, @0x0b87
	// 0262 0601      cmpis       $AC0.M, #0x01
	// 0263 0295 0267 jz          0x0267
	// 0265 029f 0332 jmp         0x0332
	if (pb.state == AX_PB_STATE_RUN) {
		
		// 0267 00de 0e42 lr          $AC0.M, @0x0e42
		// 0269 00fe 0e1c sr          @0x0e1c, $AC0.M
		*0x0e1c = *0x0e42
		
		// 026b 00c3 0e15 lr          $AR3, @0x0e15
		// 026d 177f      callr       $AR3
		DoSelectedSRC()
		
		// Volume Envelope Processing
		// 026e 8e00      set16       
		// 026f 8a00      m2          
		// 0270 8100      clr         $ACC0
		// 0271 8900      clr         $ACC1
		// 0272 00de 0bb3 lr          $AC0.M, @0x0bb3		// currentDelta (s16)
		// 0274 00df 0bb2 lr          $AC1.M, @0x0bb2		// currentVolume (u16)
		// 0276 1f1f      mrr         $AX0.L, $AC1.M
		// 0277 4d00      add         $ACC1, $ACC0
		// 0278 1481      asl         $ACC0, #1
		// 0279 8d1e      set15'mv    : $AX1.H, $AC0.M		// unsigned mulx, 
		// 027a 1fd8      mrr         $AC0.M, $AX0.L
		// 027b 0098 8000 lri         $AX0.L, #0x8000
		// 027d 0080 0e44 lri         $AR0, #0x0e44		
		// 027f a830      mulx's      $AX0.L, $AX1.H : @$AR0, $AC0.M
		// 0280 ac38      mulxac's    $AX0.L, $AX1.H, $ACC0 : @$AR0, $AC1.M
		// 0281 ad30      mulxac's    $AX0.L, $AX1.H, $ACC1 : @$AR0, $AC0.M
		// 0282 ac38      mulxac's    $AX0.L, $AX1.H, $ACC0 : @$AR0, $AC1.M
		// 0283 ad30      mulxac's    $AX0.L, $AX1.H, $ACC1 : @$AR0, $AC0.M
		// 0284 ac38      mulxac's    $AX0.L, $AX1.H, $ACC0 : @$AR0, $AC1.M
		// 0285 ad30      mulxac's    $AX0.L, $AX1.H, $ACC1 : @$AR0, $AC0.M
		// 0286 ac38      mulxac's    $AX0.L, $AX1.H, $ACC0 : @$AR0, $AC1.M
		// 0287 ad30      mulxac's    $AX0.L, $AX1.H, $ACC1 : @$AR0, $AC0.M
		// 0288 ac38      mulxac's    $AX0.L, $AX1.H, $ACC0 : @$AR0, $AC1.M
		// 0289 ad30      mulxac's    $AX0.L, $AX1.H, $ACC1 : @$AR0, $AC0.M
		// 028a ac38      mulxac's    $AX0.L, $AX1.H, $ACC0 : @$AR0, $AC1.M
		// 028b ad30      mulxac's    $AX0.L, $AX1.H, $ACC1 : @$AR0, $AC0.M
		// 028c ac38      mulxac's    $AX0.L, $AX1.H, $ACC0 : @$AR0, $AC1.M
		// 028d ad30      mulxac's    $AX0.L, $AX1.H, $ACC1 : @$AR0, $AC0.M
		// 028e ac38      mulxac's    $AX0.L, $AX1.H, $ACC0 : @$AR0, $AC1.M
		// 028f ad30      mulxac's    $AX0.L, $AX1.H, $ACC1 : @$AR0, $AC0.M
		// 0290 ac38      mulxac's    $AX0.L, $AX1.H, $ACC0 : @$AR0, $AC1.M
		// 0291 ad30      mulxac's    $AX0.L, $AX1.H, $ACC1 : @$AR0, $AC0.M
		// 0292 ac38      mulxac's    $AX0.L, $AX1.H, $ACC0 : @$AR0, $AC1.M
		// 0293 ad30      mulxac's    $AX0.L, $AX1.H, $ACC1 : @$AR0, $AC0.M
		// 0294 ac38      mulxac's    $AX0.L, $AX1.H, $ACC0 : @$AR0, $AC1.M
		// 0295 ad30      mulxac's    $AX0.L, $AX1.H, $ACC1 : @$AR0, $AC0.M
		// 0296 ac38      mulxac's    $AX0.L, $AX1.H, $ACC0 : @$AR0, $AC1.M
		// 0297 ad30      mulxac's    $AX0.L, $AX1.H, $ACC1 : @$AR0, $AC0.M
		// 0298 ac38      mulxac's    $AX0.L, $AX1.H, $ACC0 : @$AR0, $AC1.M
		// 0299 ad30      mulxac's    $AX0.L, $AX1.H, $ACC1 : @$AR0, $AC0.M
		// 029a ac38      mulxac's    $AX0.L, $AX1.H, $ACC0 : @$AR0, $AC1.M
		// 029b ad30      mulxac's    $AX0.L, $AX1.H, $ACC1 : @$AR0, $AC0.M
		// 029c ac38      mulxac's    $AX0.L, $AX1.H, $ACC0 : @$AR0, $AC1.M
		// 029d ad30      mulxac's    $AX0.L, $AX1.H, $ACC1 : @$AR0, $AC0.M
		// 029e ac38      mulxac's    $AX0.L, $AX1.H, $ACC0 : @$AR0, $AC1.M
		// 029f 00fe 0bb2 sr          @0x0bb2, $AC0.M
		
		u40 temp1 = pb.ve.currentVolume << 16
		u40 temp2 = (pb.ve.currentVolume + pb.ve.currentDelta) << 16
		*0x0e44 = temp1 >> 16
		*0x0e45 = temp2 >> 16
		
		u40 PROD = (u16)0x8000 * (u16)(pb.ve.currentDelta << 1) * 2
		for (u16* i = 0x0e46; i < 0x0e46 + 30; i+=2) {
			temp1 += PROD
			temp2 += PROD
			
			*i = temp1 >> 16
			*(i + 1) = temp2 >> 16
		}
		temp1 += PROD
		pb.ve.currentVolume = temp1 >> 16

		// 02a1 8f00      set40       
		// 02a2 0080 0e44 lri         $AR0, #0x0e44
		// 02a4 00c1 0e43 lr          $AR1, @0x0e43
		// 02a6 1c61      mrr         $AR3, $AR1
		// 02a7 193a      lrri        $AX0.H, @$AR1
		// 02a8 1918      lrri        $AX0.L, @$AR0
		// 02a9 9059      mul'l       $AX0.L, $AX0.H : $AX1.H, @$AR1
		// 02aa 1919      lrri        $AX1.L, @$AR0
		// 02ab 9e51      mulmv'l     $AX1.L, $AX1.H, $ACC0 : $AX0.H, @$AR1
		// 02ac 8080      nx'ls       : $AX0.L, $AC0.M
		// 02ad 9759      mulmv'l     $AX0.L, $AX0.H, $ACC1 : $AX1.H, @$AR1
		// 02ae 8091      nx'ls       : $AX1.L, $AC1.M
		// 02af 9e51      mulmv'l     $AX1.L, $AX1.H, $ACC0 : $AX0.H, @$AR1
		// 02b0 8080      nx'ls       : $AX0.L, $AC0.M
		// 02b1 9759      mulmv'l     $AX0.L, $AX0.H, $ACC1 : $AX1.H, @$AR1
		// 02b2 8091      nx'ls       : $AX1.L, $AC1.M
		// 02b3 9e51      mulmv'l     $AX1.L, $AX1.H, $ACC0 : $AX0.H, @$AR1
		// 02b4 8080      nx'ls       : $AX0.L, $AC0.M
		// 02b5 9759      mulmv'l     $AX0.L, $AX0.H, $ACC1 : $AX1.H, @$AR1
		// 02b6 8091      nx'ls       : $AX1.L, $AC1.M
		// 02b7 9e51      mulmv'l     $AX1.L, $AX1.H, $ACC0 : $AX0.H, @$AR1
		// 02b8 8080      nx'ls       : $AX0.L, $AC0.M
		// 02b9 9759      mulmv'l     $AX0.L, $AX0.H, $ACC1 : $AX1.H, @$AR1
		// 02ba 8091      nx'ls       : $AX1.L, $AC1.M
		// 02bb 9e51      mulmv'l     $AX1.L, $AX1.H, $ACC0 : $AX0.H, @$AR1
		// 02bc 8080      nx'ls       : $AX0.L, $AC0.M
		// 02bd 9759      mulmv'l     $AX0.L, $AX0.H, $ACC1 : $AX1.H, @$AR1
		// 02be 8091      nx'ls       : $AX1.L, $AC1.M
		// 02bf 9e51      mulmv'l     $AX1.L, $AX1.H, $ACC0 : $AX0.H, @$AR1
		// 02c0 8080      nx'ls       : $AX0.L, $AC0.M
		// 02c1 9759      mulmv'l     $AX0.L, $AX0.H, $ACC1 : $AX1.H, @$AR1
		// 02c2 8091      nx'ls       : $AX1.L, $AC1.M
		// 02c3 9e51      mulmv'l     $AX1.L, $AX1.H, $ACC0 : $AX0.H, @$AR1
		// 02c4 8080      nx'ls       : $AX0.L, $AC0.M
		// 02c5 9759      mulmv'l     $AX0.L, $AX0.H, $ACC1 : $AX1.H, @$AR1
		// 02c6 8091      nx'ls       : $AX1.L, $AC1.M
		// 02c7 9e51      mulmv'l     $AX1.L, $AX1.H, $ACC0 : $AX0.H, @$AR1
		// 02c8 8080      nx'ls       : $AX0.L, $AC0.M
		// 02c9 9759      mulmv'l     $AX0.L, $AX0.H, $ACC1 : $AX1.H, @$AR1
		// 02ca 8091      nx'ls       : $AX1.L, $AC1.M
		// 02cb 9e51      mulmv'l     $AX1.L, $AX1.H, $ACC0 : $AX0.H, @$AR1
		// 02cc 8080      nx'ls       : $AX0.L, $AC0.M
		// 02cd 9759      mulmv'l     $AX0.L, $AX0.H, $ACC1 : $AX1.H, @$AR1
		// 02ce 8091      nx'ls       : $AX1.L, $AC1.M
		// 02cf 9e51      mulmv'l     $AX1.L, $AX1.H, $ACC0 : $AX0.H, @$AR1
		// 02d0 8080      nx'ls       : $AX0.L, $AC0.M
		// 02d1 9759      mulmv'l     $AX0.L, $AX0.H, $ACC1 : $AX1.H, @$AR1
		// 02d2 8091      nx'ls       : $AX1.L, $AC1.M
		// 02d3 9e51      mulmv'l     $AX1.L, $AX1.H, $ACC0 : $AX0.H, @$AR1
		// 02d4 8080      nx'ls       : $AX0.L, $AC0.M
		// 02d5 9759      mulmv'l     $AX0.L, $AX0.H, $ACC1 : $AX1.H, @$AR1
		// 02d6 8091      nx'ls       : $AX1.L, $AC1.M
		// 02d7 9e51      mulmv'l     $AX1.L, $AX1.H, $ACC0 : $AX0.H, @$AR1
		// 02d8 8080      nx'ls       : $AX0.L, $AC0.M
		// 02d9 9759      mulmv'l     $AX0.L, $AX0.H, $ACC1 : $AX1.H, @$AR1
		// 02da 8091      nx'ls       : $AX1.L, $AC1.M
		// 02db 9e51      mulmv'l     $AX1.L, $AX1.H, $ACC0 : $AX0.H, @$AR1
		// 02dc 8080      nx'ls       : $AX0.L, $AC0.M
		// 02dd 9759      mulmv'l     $AX0.L, $AX0.H, $ACC1 : $AX1.H, @$AR1
		// 02de 8091      nx'ls       : $AX1.L, $AC1.M
		// 02df 9e51      mulmv'l     $AX1.L, $AX1.H, $ACC0 : $AX0.H, @$AR1
		// 02e0 8080      nx'ls       : $AX0.L, $AC0.M
		// 02e1 9759      mulmv'l     $AX0.L, $AX0.H, $ACC1 : $AX1.H, @$AR1
		// 02e2 8091      nx'ls       : $AX1.L, $AC1.M
		// 02e3 9e51      mulmv'l     $AX1.L, $AX1.H, $ACC0 : $AX0.H, @$AR1
		// 02e4 8080      nx'ls       : $AX0.L, $AC0.M
		// 02e5 9759      mulmv'l     $AX0.L, $AX0.H, $ACC1 : $AX1.H, @$AR1
		// 02e6 8091      nx'ls       : $AX1.L, $AC1.M
		// 02e7 9e00      mulmv       $AX1.L, $AX1.H, $ACC0
		// 02e8 6f33      movp's      $ACC1 : @$AR3, $AC0.M
		// 02e9 1b7f      srri        @$AR3, $AC1.M
		
		u16* dst = *0x0e43
		u16* temp1 = 0x0e44
		
		for (x = 0; x < 0x20; x++) {
			*(dst + x) = ((u16)*(temp1 + x) * (u16)*(dst + x) * 2) >> 16
		}
		
		// 02ea 00c3 0e14 lr          $AR3, @0x0e14
		// 02ec 8f00      set40       
		// 02ed 8d00      set15       
		// 02ee 8a00      m2          
		// 02ef 177f      callr       $AR3
		// Keep in mind: 40bit, unsigned, *2
		DoSelectedMixer()
		
		// Note: 40bit, unsigned, *2 not changed till 0x0332
		
		// 02f0 8100      clr         $ACC0
		// 02f1 00de 0b9b lr          $AC0.M, @0x0b9b
		// 02f3 b100      tst         $ACC0
		// 02f4 0295 032a jz          0x032a
		if (pb.itd.flag != AX_PB_ITD_OFF) {
			// 02f6 00de 0e42 lr          $AC0.M, @0x0e42
			// 02f8 00fe 0e43 sr          @0x0e43, $AC0.M
			*0x0e43 = *0x0e42
		
			// 02fa 8100      clr         $ACC0
			// 02fb 8900      clr         $ACC1
			// 02fc 00de 0b9e lr          $AC0.M, @0x0b9e
			// 02fe 00df 0ba0 lr          $AC1.M, @0x0ba0
			// 0300 8200      cmp         
			// 0301 0293 0306 jle         0x0306
			if (pb.itd.shiftL > pb.itd.targetShiftL) {
				// 0303 7800      decm        $AC0.M
				// 0304 029f 0309 jmp         0x0309
				pb.itd.shiftL--
			} else if (pb.itd.shiftL < pb.itd.targetShiftL) {
				// 0306 0295 0309 jz          0x0309
				// 0308 7400      incm        $AC0.M
				pb.itd.shiftL++
			}
			// 0309 00fe 0b9e sr          @0x0b9e, $AC0.M // Store pb.itd.shiftL
			
			// 030b 00df 0e43 lr          $AC1.M, @0x0e43
			// 030d 05e0      addis       $AC1.M, #0xe0
			// 030e 4c00      add         $ACC0, $ACC1
			// 030f 00fe 0e40 sr          @0x0e40, $AC0.M
			*0x0e40 = *0x0e43 - 32
			
			// 0311 8100      clr         $ACC0
			// 0312 8900      clr         $ACC1
			// 0313 00de 0b9f lr          $AC0.M, @0x0b9f
			// 0315 00df 0ba1 lr          $AC1.M, @0x0ba1
			// 0317 8200      cmp         
			// 0318 0293 031d jle         0x031d
			if (pb.itd.shiftR > pb.itd.targetShiftR) {
				// 031a 7800      decm        $AC0.M
				// 031b 029f 0320 jmp         0x0320
				pb.itd.shiftR--
			} else if (pb.itd.shiftR < pb.itd.targetShiftR) {
				// 031d 0295 0320 jz          0x0320
				// 031f 7400      incm        $AC0.M
				pb.itd.shiftR++
			}
			// 0320 00fe 0b9f sr          @0x0b9f, $AC0.M // Store pb.itd.shiftR
			
			// 0322 00df 0e43 lr          $AC1.M, @0x0e43
			// 0324 05e0      addis       $AC1.M, #0xe0
			// 0325 4c00      add         $ACC0, $ACC1
			// 0326 00fe 0e41 sr          @0x0e41, $AC0.M
			*0x0e41 = *0x0e43 - 32
			
			0328 029f 0332 jmp         0x0332
		
		} else { // pb.itd.flag == AX_PB_ITD_OFF
		
			// 032a 00de 0e42 lr          $AC0.M, @0x0e42
			// 032c 00fe 0e40 sr          @0x0e40, $AC0.M
			// 032e 00fe 0e41 sr          @0x0e41, $AC0.M
			// 0330 00fe 0e43 sr          @0x0e43, $AC0.M
			*0x0e40 = *0x0e42
			*0x0e41 = *0x0e42
			*0x0e43 = *0x0e42
		}
	}


	// 0332 8100      clr         $ACC0
	// 0333 8e00      set16       
	// 0334 8400      clrp        
	// 0335 8900      clr         $ACC1
	// 0336 1efe      mrr         $PROD.M2, $AC0.M
	// 0337 0e40      lris        $AC0.M, #0x40
	// 0338 1ebe      mrr         $PROD.M1, $AC0.M	
	// 0339 0083 0e08 lri         $AR3, #0x0e08
	// 033b 1c03      mrr         $AR0, $AR3
	// 033c 1ff5      mrr         $AC1.M, $PROD.M1
	// 033d 191a      lrri        $AX0.H, @$AR0	
	// 033e f858      addpaxz'l   $ACC0, $AX0.H : $AX1.H, @$AR0	
	// 033f fba0      addpaxz'ls  $ACC1, $AX1.H : $AX0.H, $AC0.M	
	// 0340 f8b1      addpaxz'ls  $ACC0, $AX0.H : $AX1.H, $AC1.M
	// 0341 fba0      addpaxz'ls  $ACC1, $AX1.H : $AX0.H, $AC0.M	
	// 0342 f8b1      addpaxz'ls  $ACC0, $AX0.H : $AX1.H, $AC1.M
	// 0343 fba0      addpaxz'ls  $ACC1, $AX1.H : $AX0.H, $AC0.M	
	// 0344 f8b1      addpaxz'ls  $ACC0, $AX0.H : $AX1.H, $AC1.M
	// 0345 fba0      addpaxz'ls  $ACC1, $AX1.H : $AX0.H, $AC0.M	
	// 0346 f83b      addpaxz's   $ACC0, $AX0.H : @$AR3, $AC1.M	
	// 0347 1b7e      srri        @$AR3, $AC0.M
	
	for (u16* i = 0x0e08; i <= 0x0e10; i++) {
		*i = (u16)( (0xff00400000 + (u40)(*i << 16)) >> 16 )
	}
	
	// 0348 0083 0e04 lri         $AR3, #0x0e04
	// 034a 8100      clr         $ACC0
	// 034b 8973      clr'l       $ACC1 : $AC0.M, @$AR3
	// 034c 1961      lrri        $AR1, @$AR3 // 0x0e05
	// 034d 1960      lrri        $AR0, @$AR3 // 0x0e06
	// 034e 7800      decm        $AC0.M
	// 034f 00fe 0e04 sr          @0x0e04, $AC0.M
	// 0351 0294 0253 jnz         0x0253
	ms_remaining--
	if (ms_remaining)
		goto NextMillisecUpd
	
	// 0353 8e00      set16       
	// 0354 8100      clr         $ACC0
	// 0355 00de 0b9b lr          $AC0.M, @0x0b9b
	// 0357 b100      tst         $ACC0
	// 0358 0295 036a jz          0x036a
	if (pb.itd.flag != AX_PB_ITD_OFF) {

		// 035a 00de 0b9c lr          $AC0.M, @0x0b9c
		// 035c 00dc 0b9d lr          $AC0.L, @0x0b9d
		// 035e 2ece      srs         @DSMAH, $AC0.M
		// 035f 2ccf      srs         @DSMAL, $AC0.L
		// 0360 8100      clr         $ACC0
		// 0361 00de 0e1c lr          $AC0.M, @0x0e1c
		// 0363 2ecd      srs         @DSPA, $AC0.M
		// 0364 16c9 0001 si          @DSCR, #0x0001
		// 0366 16cb 0040 si          @DSBL, #0x0040
		
		// DMA 0x40bytes from DRAM @ (*0x0e1c) to CPU @ ((pb.itd.bufferHi << 16) | pb.itd.bufferLo)
		
		// 0368 02bf 055c call        0x055c
		WaitDMA();
	}
	
	// 036a 8100      clr         $ACC0
	// 036b 8900      clr         $ACC1
	// 036c 00de 0b82 lr          $AC0.M, @0x0b82
	// 036e 00df 0b83 lr          $AC1.M, @0x0b83
	u16 maddrh = pb.currHi
	u16 maddrl = pb.currLo
	
	// This writes back the whole PB to mram from dsp
	// 0370 2ece      srs         @DSMAH, $AC0.M
	// 0371 2fcf      srs         @DSMAL, $AC1.M
	// 0372 16cd 0b80 si          @DSPA, #0x0b80
	// 0374 16c9 0001 si          @DSCR, #0x0001
	// 0376 16cb 00c0 si          @DSBL, #0x00c0
	
	// DMA 0xc0bytes from DRAM @ 0x0b80 to CPU @ maddr
	
	// 0378 02bf 055c call        0x055c
	WaitDMA();
	
	// 037a 8100      clr         $ACC0
	// 037b 00de 0b80 lr          $AC0.M, @0x0b80
	// 037d 00dc 0b81 lr          $AC0.L, @0x0b81
	// 037f b100      tst         $ACC0
	// 0380 0294 0386 jnz         0x0386
	if (((pb.nextHi << 16) | pb.nextLo) == 0) {
		// No more PBs!
		
		// Restore CmdBlockBuf ptr
		0382 00c0 0e07 lr          $AR0, @0x0e07
		// 0384 029f 0068 jmp         0x0068
		goto DoNextCommand;
	}
	
	// DMA in the next PB
	// From here on out, it's the same as Cmd2, except it calls itself to process the PB it just loaded
	
	// 0386 2ece      srs         @DSMAH, $AC0.M
	// 0387 2ccf      srs         @DSMAL, $AC0.L
	// 0388 16cd 0b80 si          @DSPA, #0x0b80
	// 038a 16c9 0000 si          @DSCR, #0x0000
	// 038c 16cb 00c0 si          @DSBL, #0x00c0
	
	// DMA 0xc0bytes from CPU @ ((pb.nextHi << 16) | pb.nextLo) to DRAM @ 0x0b80
	
	// 038e 0082 0e08 lri         $AR2, #0x0e08
	// 0390 009f 0000 lri         $AC1.M, #0x0000
	// 0392 1b5f      srri        @$AR2, $AC1.M
	// 0393 009f 0140 lri         $AC1.M, #0x0140
	// 0395 1b5f      srri        @$AR2, $AC1.M
	// 0396 009f 0280 lri         $AC1.M, #0x0280
	// 0398 1b5f      srri        @$AR2, $AC1.M
	// 0399 009f 0400 lri         $AC1.M, #0x0400
	// 039b 1b5f      srri        @$AR2, $AC1.M
	// 039c 009f 0540 lri         $AC1.M, #0x0540
	// 039e 1b5f      srri        @$AR2, $AC1.M
	// 039f 009f 0680 lri         $AC1.M, #0x0680
	// 03a1 1b5f      srri        @$AR2, $AC1.M
	// 03a2 009f 07c0 lri         $AC1.M, #0x07c0
	// 03a4 1b5f      srri        @$AR2, $AC1.M
	// 03a5 009f 0900 lri         $AC1.M, #0x0900
	// 03a7 1b5f      srri        @$AR2, $AC1.M
	// 03a8 009f 0a40 lri         $AC1.M, #0x0a40
	// 03aa 1b5f      srri        @$AR2, $AC1.M
	*0x0e08 = 0x0000
	*0x0e09 = 0x0140
	*0x0e0a = 0x0280
	*0x0e0b = 0x0400
	*0x0e0c = 0x0540
	*0x0e0d = 0x0680
	*0x0e0e = 0x07c0
	*0x0e0f = 0x0900
	*0x0e10 = 0x0a40
	
	// 03ab 02bf 055c call        0x055c
	WaitDMA();

	// 03ad 00de 0ba7 lr          $AC0.M, @0x0ba7
	// 03af 00df 0ba8 lr          $AC1.M, @0x0ba8
	// 03b1 2ece      srs         @DSMAH, $AC0.M
	// 03b2 2fcf      srs         @DSMAL, $AC1.M
	// 03b3 16cd 03c0 si          @DSPA, #0x03c0
	// 03b5 16c9 0000 si          @DSCR, #0x0000
	// 03b7 16cb 0080 si          @DSBL, #0x0080
	
	// DMA 0x80bytes from CPU @ ((pb.update.dataHi << 16) | pb.update.dataLo) to DRAM @ 0x03c0
	
	// 03b9 8100      clr         $ACC0
	// 03ba 8900      clr         $ACC1
	
	// 03bb 00de 0b84 lr          $AC0.M, @0x0b84
	// 03bd 009f 0b31 lri         $AC1.M, #0x0b31
	// 03bf 4c00      add         $ACC0, $ACC1
	// 03c0 1c7e      mrr         $AR3, $AC0.M
	// 03c1 0213      ilrr        $AC0.M, @$AR3
	// 03c2 00fe 0e15 sr          @0x0e15, $AC0.M
	*0x0e15 = *(0x0b31 + pb.srcSelect) // func ptr for src
	
	// 03c4 00de 0b85 lr          $AC0.M, @0x0b85
	// 03c6 009f 0b34 lri         $AC1.M, #0x0b34
	// 03c8 4c00      add         $ACC0, $ACC1
	// 03c9 1c7e      mrr         $AR3, $AC0.M
	// 03ca 0213      ilrr        $AC0.M, @$AR3
	// 03cb 00fe 0e16 sr          @0x0e16, $AC0.M
	*0x0e16 = *(0x0b34 + pb.coefSelect) // ptr to coef table
	
	// 03cd 00de 0b86 lr          $AC0.M, @0x0b86
	// 03cf 009f 0b11 lri         $AC1.M, #0x0b11
	// 03d1 4c00      add         $ACC0, $ACC1
	// 03d2 1c7e      mrr         $AR3, $AC0.M
	// 03d3 0213      ilrr        $AC0.M, @$AR3
	// 03d4 00fe 0e14 sr          @0x0e14, $AC0.M
	*0x0e14 = *(0x0b11 + pb.mixerCtrl) // func ptr for mixer
	
	// 03d6 8100      clr         $ACC0
	// 03d7 00de 0b9b lr          $AC0.M, @0x0b9b
	// 03d9 b100      tst         $ACC0
	// 03da 0295 0403 jz          0x0403
	if (pb.itd.flag != AX_PB_ITD_OFF) {
		// 03dc 8900      clr         $ACC1
		// 03dd 00df 0b9e lr          $AC1.M, @0x0b9e
		// 03df 0300 0cc0 addi        $AC1.M, #0x0cc0
		// 03e1 00ff 0e40 sr          @0x0e40, $AC1.M
		*0x0e40 = 0x0cc0 + pb.itd.shiftL
		
		// 03e3 00df 0b9f lr          $AC1.M, @0x0b9f
		// 03e5 0300 0cc0 addi        $AC1.M, #0x0cc0
		// 03e7 00ff 0e41 sr          @0x0e41, $AC1.M
		*0x0e41 = 0x0cc0 + pb.itd.shiftR
		
		// 03e9 009f 0ce0 lri         $AC1.M, #0x0ce0
		// 03eb 00ff 0e42 sr          @0x0e42, $AC1.M
		// 03ed 00ff 0e43 sr          @0x0e43, $AC1.M
		*0x0e42 = 0x0ce0
		*0x0e43 = 0x0ce0

		// 03ef 02bf 055c call        0x055c
		WaitDMA();

		// 03f1 00de 0b9c lr          $AC0.M, @0x0b9c
		// 03f3 2ece      srs         @DSMAH, $AC0.M
		// 03f4 00de 0b9d lr          $AC0.M, @0x0b9d
		// 03f6 2ecf      srs         @DSMAL, $AC0.M
		// 03f7 16cd 0cc0 si          @DSPA, #0x0cc0
		// 03f9 16c9 0000 si          @DSCR, #0x0000
		// 03fb 16cb 0040 si          @DSBL, #0x0040
		
		// DMA 0x0040bytes to DMEM @ 0x0cc0 from CPU @ (pb.itd.bufferHi << 16) | pb.itd.bufferLo

		// 03fd 02bf 055c call        0x055c
		WaitDMA();

		// Restore CmdBlockBuf ptr
		03ff 00c0 0e07 lr          $AR0, @0x0e07
		// 0401 029f 0248 jmp         0x0248
		goto Cmd_3() // Calls itself till there are no more PBs linked
		
	} else {
	
		// 0403 009f 0ce0 lri         $AC1.M, #0x0ce0
		// 0405 00ff 0e42 sr          @0x0e42, $AC1.M
		// 0407 00ff 0e40 sr          @0x0e40, $AC1.M
		// 0409 00ff 0e41 sr          @0x0e41, $AC1.M
		// 040b 00ff 0e43 sr          @0x0e43, $AC1.M
		*0x0e42 = 0x0ce0
		*0x0e40 = 0x0ce0
		*0x0e41 = 0x0ce0
		*0x0e43 = 0x0ce0

		// 040d 02bf 055c call        0x055c
		WaitDMA();

		// Restore CmdBlockBuf ptr
		040f 00c0 0e07 lr          $AR0, @0x0e07
		// 0411 029f 0248 jmp         0x0248
		goto Cmd_3() // Calls itself till there are no more PBs linked
	}
}

void Cmd_4() {
	0413 8e00      set16       
	
	0414 0086 0400 lri         $IX2, #0x0400 // buffer in dram
	
	// 0416 8100      clr         $ACC0
	// 0417 8970      clr'l       $ACC1 : $AC0.M, @$AR0
	// 0418 191c      lrri        $AC0.L, @$AR0
	u16 maddrh = *(CmdBlockBuf++)
	u16 maddrl = *(CmdBlockBuf++)
	
	// 0419 2ece      srs         @DSMAH, $AC0.M
	// 041a 2ccf      srs         @DSMAL, $AC0.L
	// 041b 1fc6      mrr         $AC0.M, $IX2
	// 041c 2ecd      srs         @DSPA, $AC0.M
	// 041d 16c9 0001 si          @DSCR, #0x0001
	// 041f 16cb 0780 si          @DSBL, #0x0780
	
	// DMA 0x0780bytes from DRAM @ 0x0400 to CPU @ maddr

	// 0421 02bf 055c call        0x055c
	WaitDMA();

	0423 02bf 0484 call        0x0484
	
	// 0425 029f 0068 jmp         0x0068
	goto DoNextCommand;
}

void Cmd_5() {
	0427 8e00      set16       
	
	0428 0086 07c0 lri         $IX2, #0x07c0
	
	042a 8100      clr         $ACC0
	042b 8970      clr'l       $ACC1 : $AC0.M, @$AR0
	042c 191c      lrri        $AC0.L, @$AR0
	042d 2ece      srs         @DSMAH, $AC0.M
	042e 2ccf      srs         @DSMAL, $AC0.L
	042f 1fc6      mrr         $AC0.M, $IX2
	0430 2ecd      srs         @DSPA, $AC0.M
	0431 16c9 0001 si          @DSCR, #0x0001
	0433 16cb 0780 si          @DSBL, #0x0780

	// 0435 02bf 055c call        0x055c
	WaitDMA();

	0437 02bf 0484 call        0x0484
	
	// 0439 029f 0068 jmp         0x0068
	goto DoNextCommand;
}

void Cmd_E() {
	043b 8c00      clr15       
	043c 8a00      m2          
	043d 8100      clr         $ACC0
	043e 8970      clr'l       $ACC1 : $AC0.M, @$AR0
	043f 191f      lrri        $AC1.M, @$AR0
	0440 2ece      srs         @DSMAH, $AC0.M
	0441 2fcf      srs         @DSMAL, $AC1.M
	0442 16cd 0280 si          @DSPA, #0x0280
	0444 16c9 0001 si          @DSCR, #0x0001 // DMEM -> CPU
	0446 16cb 0280 si          @DSBL, #0x0280
	
	0448 8f50      set40'l     : $AX0.H, @$AR0
	0449 8140      clr'l       $ACC0 : $AX0.L, @$AR0
	044a 0081 0400 lri         $AR1, #0x0400
	044c 0083 0000 lri         $AR3, #0x0000
	044e 0082 0140 lri         $AR2, #0x0140
	0450 0099 0080 lri         $AX1.L, #0x0080

	// 0452 02bf 055c call        0x055c
	WaitDMA();

	0454 1105 046c bloopi      #0x05, 0x046c
		0456 1f61      mrr         $AX1.H, $AR1
		
		0457 1120 045e bloopi      #0x20, 0x045e
			0459 8972      clr'l       $ACC1 : $AC0.M, @$AR2
			045a 195c      lrri        $AC0.L, @$AR2
			045b f07b      lsl16'l     $ACC0 : $AC1.M, @$AR3
			045c 197d      lrri        $AC1.L, @$AR3
			045d f131      lsl16's     $ACC1 : @$AR1, $AC0.M
			045e 8139      clr's       $ACC0 : @$AR1, $AC1.M
			
		045f 8900      clr         $ACC1
		0460 6800      movax       $ACC0, $AX0
		0461 2ece      srs         @DSMAH, $AC0.M
		0462 2ccf      srs         @DSMAL, $AC0.L
		0463 1ffb      mrr         $AC1.M, $AX1.H
		0464 2fcd      srs         @DSPA, $AC1.M
		0465 0f01      lris        $AC1.M, #0x01
		0466 2fc9      srs         @DSCR, $AC1.M
		0467 1ff9      mrr         $AC1.M, $AX1.L
		0468 2fcb      srs         @DSBL, $AC1.M
		0469 7200      addaxl      $ACC0, $AX1.L
		046a 1f5e      mrr         $AX0.H, $AC0.M
		046b 1f1c      mrr         $AX0.L, $AC0.L
		046c 8100      clr         $ACC0
 	
	// 046d 26c9      lrs         $AC0.M, @DSCR
	// 046e 02a0 0004 andf        $AC0.M, #0x0004
	// 0470 029c 046d jlnz        0x046d
	while (@DSCR & 4);
	
	// 0472 029f 0068 jmp         0x0068
	goto DoNextCommand;
}

void UnimplimentedCmd_B() {
	// 0474 029f 0068 jmp         0x0068
	goto DoNextCommand;
}

void UnimplimentedCmd_C() {
	// 0476 029f 0068 jmp         0x0068
	goto DoNextCommand;
}

void UnimplimentedCmd_A() {
	// 0478 029f 0068 jmp         0x0068
	goto DoNextCommand;
}

void Task_Yield() {
	// Send DSP_YIELD mail
	// 047a 16fc dcd1 si          @DMBH, #0xdcd1
	// 047c 16fd 0002 si          @DMBL, #0x0002
	DMB = 0xdcd10002
	// 047e 16fb 0001 si          @DIRQ, #0x0001
	
	0480 029f 0c91 jmp         0x0c91
}
	
	// Unused?
	// 0482 029f 0045 jmp         0x0045
	goto GetNextCmdBlock;

// Called by cmds 4 5 9
// IX2 is always modified before calling...
void UnkFunc() {
	0484 8e00      set16       
	0485 191f      lrri        $AC1.M, @$AR0
	0486 191d      lrri        $AC1.L, @$AR0
	0487 1f5f      mrr         $AX0.H, $AC1.M
	0488 1f1d      mrr         $AX0.L, $AC1.L
	0489 2fce      srs         @DSMAH, $AC1.M
	048a 2dcf      srs         @DSMAL, $AC1.L
	048b 8900      clr         $ACC1
	048c 1fa6      mrr         $AC1.L, $IX2
	048d 2dcd      srs         @DSPA, $AC1.L
	048e 0e00      lris        $AC0.M, #0x00
	048f 2ec9      srs         @DSCR, $AC0.M
	0490 8100      clr         $ACC0
	0491 009c 00c0 lri         $AC0.L, #0x00c0
	0493 2ccb      srs         @DSBL, $AC0.L
	0494 1ca0      mrr         $IX1, $AR0
	0495 0081 0e44 lri         $AR1, #0x0e44
	0497 4800      addax       $ACC0, $AX0
	0498 1b3e      srri        @$AR1, $AC0.M
	0499 1b3c      srri        @$AR1, $AC0.L
	049a 0b00      lris        $AX1.H, #0x00
	049b 0099 0060 lri         $AX1.L, #0x0060
	049d 4b00      addax       $ACC1, $AX1
	049e 1b3d      srri        @$AR1, $AC1.L
	049f 0081 0e44 lri         $AR1, #0x0e44
	04a1 1c06      mrr         $AR0, $IX2
	04a2 0083 0000 lri         $AR3, #0x0000
	04a4 1c43      mrr         $AR2, $AR3
	
	04a5 27c9      lrs         $AC1.M, @DSCR
	04a6 03a0 0004 andf        $AC1.M, #0x0004
	04a8 029c 04a5 jlnz        0x04a5
	
	04aa 1109 04da bloopi      #0x09, 0x04da
		04ac 8e00      set16       
		04ad 193a      lrri        $AX0.H, @$AR1
		04ae 1938      lrri        $AX0.L, @$AR1
		04af 6900      movax       $ACC1, $AX0
		04b0 2fce      srs         @DSMAH, $AC1.M
		04b1 2dcf      srs         @DSMAL, $AC1.L
		04b2 8900      clr         $ACC1
		04b3 193d      lrri        $AC1.L, @$AR1
		04b4 2dcd      srs         @DSPA, $AC1.L
		04b5 16c9 0000 si          @DSCR, #0x0000
		04b7 8100      clr         $ACC0
		04b8 009c 00c0 lri         $AC0.L, #0x00c0
		04ba 2ccb      srs         @DSBL, $AC0.L
		04bb 0081 0e44 lri         $AR1, #0x0e44
		04bd 4800      addax       $ACC0, $AX0
		04be 1b3e      srri        @$AR1, $AC0.M
		04bf 1b3c      srri        @$AR1, $AC0.L
		04c0 0b00      lris        $AX1.H, #0x00
		04c1 0960      lris        $AX1.L, #0x60
		04c2 4b00      addax       $ACC1, $AX1
		04c3 1b3d      srri        @$AR1, $AC1.L
		04c4 0081 0e44 lri         $AR1, #0x0e44
		04c6 8f00      set40       
		04c7 80f0      nx'ld       : $AX0.H, $AX1.H, @$AR0
		04c8 80c0      nx'ld       : $AX0.L, $AX1.L, @$AR0
		04c9 6a00      movax       $ACC0, $AX1
		04ca 4800      addax       $ACC0, $AX0
		04cb 1117 04d4 bloopi      #0x17, 0x04d4
			04cd 80f0      nx'ld       : $AX0.H, $AX1.H, @$AR0
			04ce 80c0      nx'ld       : $AX0.L, $AX1.L, @$AR0
			04cf 6b32      movax's     $ACC1, $AX1.L : @$AR2, $AC0.M
			04d0 4922      addax's     $ACC1, $AX0.L : @$AR2, $AC0.L
			04d1 80f0      nx'ld       : $AX0.H, $AX1.H, @$AR0
			04d2 80c0      nx'ld       : $AX0.L, $AX1.L, @$AR0
			04d3 6a3a      movax's     $ACC0, $AX1.L : @$AR2, $AC1.M
			04d4 482a      addax's     $ACC0, $AX0.L : @$AR2, $AC1.L
		04d5 80f0      nx'ld       : $AX0.H, $AX1.H, @$AR0
		04d6 80c0      nx'ld       : $AX0.L, $AX1.L, @$AR0
		04d7 6b32      movax's     $ACC1, $AX1.L : @$AR2, $AC0.M
		04d8 4922      addax's     $ACC1, $AX0.L : @$AR2, $AC0.L
		04d9 1b5f      srri        @$AR2, $AC1.M
		04da 1b5d      srri        @$AR2, $AC1.L

	04db 80f0      nx'ld       : $AX0.H, $AX1.H, @$AR0
	04dc 80c0      nx'ld       : $AX0.L, $AX1.L, @$AR0
	04dd 6a00      movax       $ACC0, $AX1
	04de 4800      addax       $ACC0, $AX0
	
	04df 1117 04e8 bloopi      #0x17, 0x04e8
		04e1 80f0      nx'ld       : $AX0.H, $AX1.H, @$AR0
		04e2 80c0      nx'ld       : $AX0.L, $AX1.L, @$AR0
		04e3 6b32      movax's     $ACC1, $AX1.L : @$AR2, $AC0.M
		04e4 4922      addax's     $ACC1, $AX0.L : @$AR2, $AC0.L
		04e5 80f0      nx'ld       : $AX0.H, $AX1.H, @$AR0
		04e6 80c0      nx'ld       : $AX0.L, $AX1.L, @$AR0
		04e7 6a3a      movax's     $ACC0, $AX1.L : @$AR2, $AC1.M
		04e8 482a      addax's     $ACC0, $AX0.L : @$AR2, $AC1.L
		
	04e9 80f0      nx'ld       : $AX0.H, $AX1.H, @$AR0
	04ea 80c0      nx'ld       : $AX0.L, $AX1.L, @$AR0
	04eb 6b32      movax's     $ACC1, $AX1.L : @$AR2, $AC0.M
	04ec 4922      addax's     $ACC1, $AX0.L : @$AR2, $AC0.L
	04ed 1b5f      srri        @$AR2, $AC1.M
	04ee 1b5d      srri        @$AR2, $AC1.L
	04ef 1c05      mrr         $AR0, $IX1
	04f0 02df      ret         
}

// Only called by Command 1
// AX0 = maddr
// AX1.L = unkForMulBuffer1
// AR1 = unkForMulBuffer2
void Unk(maddr, unkForMulBuffer1, unkForMulBuffer2) {
	04f1 8e00      set16       
	
	// 04f2 009b 0e44 lri         $AX1.H, #0x0e44
	// 04f4 009d 00c0 lri         $AC1.L, #0x00c0
	// 04f6 02bf 0541 call        0x0541
	u16 daddr = 0x0e44
	const u16 dma_len = 0x00c0
	DMA_CPUToDMEM(maddr, daddr, dma_len);

	// 04f8 4900      addax       $ACC1, $AX0
	// 04f9 00ff 0e1d sr          @0x0e1d, $AC1.M
	// 04fb 00fd 0e1e sr          @0x0e1e, $AC1.L
	// 04fd 8900      clr         $ACC1
	maddr += dma_len
	
	// 04fe 02bf 055c call        0x055c
	WaitDMA();

	// 0500 1104 052c bloopi      #0x04, 0x052c
	for (u8 i = 0; i < 4; i++) {
		// 0502 00da 0e1d lr          $AX0.H, @0x0e1d // restore
		// 0504 00d8 0e1e lr          $AX0.L, @0x0e1e // restore
		// 0506 009b 0ea4 lri         $AX1.H, #0x0ea4 // buffer 2
		// 0508 009d 00c0 lri         $AC1.L, #0x00c0 // restore
		// 050a 02bf 0541 call        0x0541
		daddr = 0x0ea4
		DMA_CPUToDMEM(maddr, daddr, dma_len);

		// 050c 4900      addax       $ACC1, $AX0
		// 050d 00ff 0e1d sr          @0x0e1d, $AC1.M // update
		// 050f 00fd 0e1e sr          @0x0e1e, $AC1.L
		maddr += dma_len
		
		// 0511 0083 0e44 lri         $AR3, #0x0e44
		// 0513 02bf 054c call        0x054c
		UnknownMulBuffer(0x0e44);
		
		// 0515 8900      clr         $ACC1
		// 0516 00da 0e1d lr          $AX0.H, @0x0e1d // restore
		// 0518 00d8 0e1e lr          $AX0.L, @0x0e1e // restore
		// 051a 009b 0e44 lri         $AX1.H, #0x0e44 // buffer 1
		// 051c 009d 00c0 lri         $AC1.L, #0x00c0 // restore		
		// 051e 02bf 0541 call        0x0541
		daddr = 0x0e44
		DMA_CPUToDMEM(maddr, daddr, dma_len);

		// 0520 4900      addax       $ACC1, $AX0
		// 0521 00ff 0e1d sr          @0x0e1d, $AC1.M // update
		// 0523 00fd 0e1e sr          @0x0e1e, $AC1.L
		maddr += dma_len		
		
		// 0525 0083 0ea4 lri         $AR3, #0x0ea4 // buffer 2
		// 0527 02bf 054c call        0x054c
		UnknownMulBuffer(0x0ea4);
		
		// 0529 0000      nop         
		// 052a 0000      nop         
		// 052b 8e00      set16       // restore
		// 052c 8900      clr         $ACC1
	}
		
	// 052d 00da 0e1d lr          $AX0.H, @0x0e1d // restore
	// 052f 00d8 0e1e lr          $AX0.L, @0x0e1e // restore
	// 0531 009b 0ea4 lri         $AX1.H, #0x0ea4 // buffer 2
	// 0533 009d 00c0 lri         $AC1.L, #0x00c0 // restore
	// 0535 02bf 0541 call        0x0541
	DMA_CPUToDMEM(maddr, daddr, dma_len);
	
	// 0537 4900      addax       $ACC1, $AX0
	maddr += dma_len
	
	// 0538 0083 0e44 lri         $AR3, #0x0e44 // buffer 1
	// 053a 02bf 054c call        0x054c
	UnknownMulBuffer(0x0e44);
	
	// 053c 0083 0ea4 lri         $AR3, #0x0ea4 // buffer 2
	// 053e 02bf 054c call        0x054c
	UnknownMulBuffer(0x0ea4);
	
	0540 02df      ret
}

// u32 maddr = AX0
// u16 daddr = AX1.H
// u16 len   = AC1.L
// Only transfers from CPU -> DMEM
void DMA_CPUToDMEM() {
	0541 8e00      set16       
	0542 00fa ffce sr          @DSMAH, $AX0.H
	0544 00f8 ffcf sr          @DSMAL, $AX0.L
	0546 00fb ffcd sr          @DSPA, $AX1.H
	0548 16c9 0000 si          @DSCR, #0x0000
	054a 2dcb      srs         @DSBL, $AC1.L
	054b 02df      ret
}

// IX1 = 0xffff
// AX1.L = unkForMulBuffer1 (next value in cmd block)
// AR1 = unkForMulBuffer2 (0, 0x0400, then 0x07c0)
// AR3 is some buffer, either 0x0e44 or 0x0ea4
void UnknownMulBuffer() {
	054c 8f00      set40       // Loaded ACx.M values extend to the entire ACC
	054d 8d00      set15       // multiplicands unsigned
	054e 8a00      m2          // mul results doubled
	
	// 054f 197a      lrri        $AX0.H, @$AR3
	// 0550 1978      lrri        $AX0.L, @$AR3
	AX0.H = *(AR3++)
	AX0.L = *(AR3++)
	
	// 0551 a000      mulx        $AX0.L, $AX1.L
	// 0552 b600      mulxmv      $AX0.H, $AX1.L, $ACC0
	ACC0 = (u16)AX0.L * (u16)unkForMulBuffer1 * 2
	PROD = (u16)AX0.H * (u16)unkForMulBuffer1 * 2
	
	// 0553 1130 055a bloopi      #0x30, 0x055a
	for (int i=0; i<48; i++) {
		// 0555 9179      asr16'l     $ACC0 : $AC1.M, @$AR1
		ACC0 >>= 16
		AC1.M = *(unkForMulBuffer2++)
		
		// 0556 4e6d      addp'ln     $ACC0 : $AC1.L, @$AR1
		ACC0 += PROD
		AC1.L = *unkForMulBuffer2
		unkForMulBuffer2 -= 1
		
		// 0557 197a      lrri        $AX0.H, @$AR3
		AX0.H = *(AR3++)
		
		// 0558 4d43      add'l       $ACC1, $ACC0 : $AX0.L, @$AR3
		ACC1 += ACC0
		AX0.L = *(AR3++)
		
		// 0559 a039      mulx's      $AX0.L, $AX1.L : @$AR1, $AC1.M		
		// 055a b629      mulxmv's    $AX0.H, $AX1.L, $ACC0 : @$AR1, $AC1.L
		ACC0 = (u16)AX0.L * (u16)unkForMulBuffer1 * 2
		*(unkForMulBuffer2++) = AC1.M
		PROD = (u16)AX0.H * (u16)unkForMulBuffer1 * 2
		*(unkForMulBuffer2++) = AC1.L
	}
		
	055b 02df      ret
}

void WaitDMA() {
	// 055c 26c9      lrs         $AC0.M, @DSCR
	// 055d 02a0 0004 andf        $AC0.M, #0x0004
	// 055f 029c 055c jlnz        0x055c
	while (@DSCR & 4);
	
	// 0561 02df      ret
	return;
}

// All apparently unused?
void WaitForCPUMailbox() { 
	0562 26fe      lrs         $AC0.M, @CMBH
	0563 02c0 8000 andcf       $AC0.M, #0x8000
	0565 029c 0562 jlnz        0x0562
	0567 02df      ret
}
void WaitForDSPMailbox1() {
	0568 26fc      lrs         $AC0.M, @DMBH
	0569 02a0 8000 andf        $AC0.M, #0x8000
	056b 029c 0568 jlnz        0x0568
	056d 02df      ret
}
void WaitForDSPMailbox2() {
	056e 26fc      lrs         $AC0.M, @DMBH
	056f 02a0 8000 andf        $AC0.M, #0x8000
	0571 029c 056e jlnz        0x056e
	0573 02df      ret
}

void Cmd_7() {
	// 0574 8100      clr         $ACC0
	// 0575 8970      clr'l       $ACC1 : $AC0.M, @$AR0
	// 0576 8e60      set16'l     : $AC0.L, @$AR0
	u16 maddrh = *(CmdBlockBuf++)
	u16 maddrl = *(CmdBlockBuf++)
	
	// 0577 2ece      srs         @DSMAH, $AC0.M
	// 0578 2ccf      srs         @DSMAL, $AC0.L
	// 0579 16cd 0e44 si          @DSPA, #0x0e44
	// 057b 16c9 0000 si          @DSCR, #0x0000
	// 057d 8900      clr         $ACC1
	// 057e 0d20      lris        $AC1.L, #0x20
	u16 dma_len = 32
	
	// 057f 2dcb      srs         @DSBL, $AC1.L
	// DMA 32bytes from CPU @ maddr -> DMEM @ 0x0e44
	
	// 0580 4c00      add         $ACC0, $ACC1
	maddr += dma_len
	
	// Push CmdBlockBuf ptr
	0581 1c80      mrr         $IX0, $AR0
	
	// 0582 0080 0280 lri         $AR0, #0x0280
	// 0584 0081 0000 lri         $AR1, #0x0000
	// 0586 0082 0140 lri         $AR2, #0x0140
	// 0588 0083 0e44 lri         $AR3, #0x0e44
	u16* unk_buf1 = 0x0280
	u16* unk_buf2 = 0x0000
	u16* unk_buf3 = 0x0140
	u16* dmem_buf = 0x0e44
	
	// 058a 0a00      lris        $AX0.H, #0x00
	const u16 null = 0 // Guess is that it's faster to use AXx instead of imm value?
	
	// 058b 27c9      lrs         $AC1.M, @DSCR
	// 058c 03a0 0004 andf        $AC1.M, #0x0004
	// 058e 029c 058b jlnz        0x058b
	while (@DSCR & 4); // Wait for DMA completion
	
	// 0590 2ece      srs         @DSMAH, $AC0.M
	// 0591 2ccf      srs         @DSMAL, $AC0.L
	// 0592 16cd 0e54 si          @DSPA, #0x0e54
	// 0594 16c9 0000 si          @DSCR, #0x0000
	// 0596 16cb 0260 si          @DSBL, #0x0260
	
	// DMA 0x0260bytes from CPU @ maddr -> DMEM @ 0x0e54
	// No waiting for DMA
	
	// 0598 009f 00a0 lri         $AC1.M, #0x00a0
	u16 size = 0x00a0
	
	// accum loads in the loop are 40bit
	// 059a 8f00      set40       
	
	// 059b 007f 05a4 bloop       $AC1.M, 0x05a4
	for (int i = 0; i < size; i++) {
	// !!! Doesn't make sense with current understanding of set40
		059d 197e      lrri        $AC0.M, @$AR3
		059e 1b1a      srri        @$AR0, $AX0.H
		059f 197c      lrri        $AC0.L, @$AR3
		05a0 1b1a      srri        @$AR0, $AX0.H
		05a1 1b5e      srri        @$AR2, $AC0.M
		05a2 1b5c      srri        @$AR2, $AC0.L
		05a3 1b3e      srri        @$AR1, $AC0.M
		05a4 1b3c      srri        @$AR1, $AC0.L
	}
	
	// Pop CmdBlockBuf ptr
	05a5 1c04      mrr         $AR0, $IX0
	
	// 05a6 029f 0068 jmp         0x0068
	goto DoNextCommand;
}

# Following 3 funcs are the SRCs to select from, in order

void SRC_Polyphase() {
	// Copy pb's data [pb.addr.format to pb.adpm.yn2] to corresponding hw regs
	// 05a8 0082 0bb8 lri         $AR2, #0x0bb8
	// 05aa 195e      lrri        $AC0.M, @$AR2
	// 05ab 2ed1      srs         @SampleFormat, $AC0.M
	// 05ac 195e      lrri        $AC0.M, @$AR2
	// 05ad 2ed4      srs         @ACSAH, $AC0.M
	// 05ae 195e      lrri        $AC0.M, @$AR2
	// 05af 2ed5      srs         @ACSAL, $AC0.M
	// 05b0 195e      lrri        $AC0.M, @$AR2
	// 05b1 2ed6      srs         @ACEAH, $AC0.M
	// 05b2 195e      lrri        $AC0.M, @$AR2
	// 05b3 2ed7      srs         @ACEAL, $AC0.M
	// 05b4 195e      lrri        $AC0.M, @$AR2
	// 05b5 2ed8      srs         @ACCAH, $AC0.M
	// 05b6 195e      lrri        $AC0.M, @$AR2
	// 05b7 2ed9      srs         @ACCAL, $AC0.M
	// 05b8 195e      lrri        $AC0.M, @$AR2
	// 05b9 2ea0      srs         @COEF_A1_0, $AC0.M
	// 05ba 195e      lrri        $AC0.M, @$AR2
	// 05bb 2ea1      srs         @COEF_A2_0, $AC0.M
	// 05bc 195e      lrri        $AC0.M, @$AR2
	// 05bd 2ea2      srs         @COEF_A1_1, $AC0.M
	// 05be 195e      lrri        $AC0.M, @$AR2
	// 05bf 2ea3      srs         @COEF_A2_1, $AC0.M
	// 05c0 195e      lrri        $AC0.M, @$AR2
	// 05c1 2ea4      srs         @COEF_A1_2, $AC0.M
	// 05c2 195e      lrri        $AC0.M, @$AR2
	// 05c3 2ea5      srs         @COEF_A2_2, $AC0.M
	// 05c4 195e      lrri        $AC0.M, @$AR2
	// 05c5 2ea6      srs         @COEF_A1_3, $AC0.M
	// 05c6 195e      lrri        $AC0.M, @$AR2
	// 05c7 2ea7      srs         @COEF_A2_3, $AC0.M
	// 05c8 195e      lrri        $AC0.M, @$AR2
	// 05c9 2ea8      srs         @COEF_A1_4, $AC0.M
	// 05ca 195e      lrri        $AC0.M, @$AR2
	// 05cb 2ea9      srs         @COEF_A2_4, $AC0.M
	// 05cc 195e      lrri        $AC0.M, @$AR2
	// 05cd 2eaa      srs         @COEF_A1_5, $AC0.M
	// 05ce 195e      lrri        $AC0.M, @$AR2
	// 05cf 2eab      srs         @COEF_A2_5, $AC0.M
	// 05d0 195e      lrri        $AC0.M, @$AR2
	// 05d1 2eac      srs         @COEF_A1_6, $AC0.M
	// 05d2 195e      lrri        $AC0.M, @$AR2
	// 05d3 2ead      srs         @COEF_A2_6, $AC0.M
	// 05d4 195e      lrri        $AC0.M, @$AR2
	// 05d5 2eae      srs         @COEF_A1_7, $AC0.M
	// 05d6 195e      lrri        $AC0.M, @$AR2
	// 05d7 2eaf      srs         @COEF_A2_7, $AC0.M
	// 05d8 195e      lrri        $AC0.M, @$AR2
	// 05d9 2ede      srs         @GAIN, $AC0.M
	// 05da 195e      lrri        $AC0.M, @$AR2
	// 05db 2eda      srs         @scale, $AC0.M
	// 05dc 195e      lrri        $AC0.M, @$AR2
	// 05dd 2edb      srs         @yn1, $AC0.M
	// 05de 195e      lrri        $AC0.M, @$AR2
	// 05df 2edc      srs         @yn2, $AC0.M
	
	05e0 8c00      clr15       
	05e1 8a00      m2          
	05e2 8e00      set16       
	05e3 00d8 0e16 lr          $AX0.L, @0x0e16
	05e5 195b      lrri        $AX1.H, @$AR2
	05e6 1959      lrri        $AX1.L, @$AR2
	05e7 8100      clr         $ACC0
	05e8 195c      lrri        $AC0.L, @$AR2
	05e9 0080 0e44 lri         $AR0, #0x0e44
	05eb 195f      lrri        $AC1.M, @$AR2
	05ec 1b1f      srri        @$AR0, $AC1.M
	05ed 195f      lrri        $AC1.M, @$AR2
	05ee 1b1f      srri        @$AR0, $AC1.M
	05ef 195f      lrri        $AC1.M, @$AR2
	05f0 1b1f      srri        @$AR0, $AC1.M
	05f1 185f      lrr         $AC1.M, @$AR2
	05f2 1b1f      srri        @$AR0, $AC1.M
	05f3 6b00      movax       $ACC1, $AX1
	05f4 1505      lsl         $ACC1, #5
	05f5 4d00      add         $ACC1, $ACC0
	05f6 157e      lsr         $ACC1, #-2
	05f7 1c9f      mrr         $IX0, $AC1.M
	05f8 1cbd      mrr         $IX1, $AC1.L
	05f9 05e0      addis       $AC1.M, #0xe0
	05fa 9900      asr16       $ACC1
	05fb 7d00      neg         $ACC1
	05fc 1cdd      mrr         $IX2, $AC1.L
	05fd 8900      clr         $ACC1
	05fe 1fa5      mrr         $AC1.L, $IX1
	05ff 1502      lsl         $ACC1, #2
	0600 1cbf      mrr         $IX1, $AC1.M
	0601 009a 01fc lri         $AX0.H, #0x01fc
	0603 009e 0e44 lri         $AC0.M, #0x0e44
	0605 0081 ffdd lri         $AR1, #0xffdd
	0607 0083 0d80 lri         $AR3, #0x0d80
	0609 0064 061a bloop       $IX0, 0x061a
		060b 1827      lrr         $IX3, @$AR1
		060c 1b07      srri        @$AR0, $IX3
		060d 4a00      addax       $ACC0, $AX1
		060e 1ffc      mrr         $AC1.M, $AC0.L
		060f 1827      lrr         $IX3, @$AR1
		0610 1b07      srri        @$AR0, $IX3
		0611 1579      lsr         $ACC1, #-7
		0612 3500      andr        $AC1.M, $AX0.H
		0613 1827      lrr         $IX3, @$AR1
		0614 1b07      srri        @$AR0, $IX3
		0615 4100      addr        $ACC1, $AX0.L
		0616 1b7e      srri        @$AR3, $AC0.M
		0617 1827      lrr         $IX3, @$AR1
		0618 1b07      srri        @$AR0, $IX3
		0619 1b7f      srri        @$AR3, $AC1.M
		061a 0000      nop         
		
	061b 0065 0620 bloop       $IX1, 0x0620
		061d 1827      lrr         $IX3, @$AR1
		061e 1b07      srri        @$AR0, $IX3
		061f 0000      nop         
		0620 0000      nop         
		
	0621 0007      dar         $AR3
	0622 187f      lrr         $AC1.M, @$AR3
	0623 0066 0629 bloop       $IX2, 0x0629
		0625 4a3b      addax's     $ACC0, $AX1.L : @$AR3, $AC1.M
		0626 1ffc      mrr         $AC1.M, $AC0.L
		0627 1579      lsr         $ACC1, #-7
		0628 3533      andr's      $AC1.M, $AX0.H : @$AR3, $AC0.M
		0629 4100      addr        $ACC1, $AX0.L
		
	062a 1b7f      srri        @$AR3, $AC1.M
	062b 0004      dar         $AR0
	062c 189f      lrrd        $AC1.M, @$AR0
	062d 1adf      srrd        @$AR2, $AC1.M
	062e 189f      lrrd        $AC1.M, @$AR0
	062f 1adf      srrd        @$AR2, $AC1.M
	0630 189f      lrrd        $AC1.M, @$AR0
	0631 1adf      srrd        @$AR2, $AC1.M
	0632 189f      lrrd        $AC1.M, @$AR0
	0633 1adf      srrd        @$AR2, $AC1.M
	0634 1adc      srrd        @$AR2, $AC0.L
	0635 0082 0bd2 lri         $AR2, #0x0bd2
	0637 27dc      lrs         $AC1.M, @yn2
	0638 1adf      srrd        @$AR2, $AC1.M
	0639 27db      lrs         $AC1.M, @yn1
	063a 1adf      srrd        @$AR2, $AC1.M
	063b 27da      lrs         $AC1.M, @scale
	063c 1adf      srrd        @$AR2, $AC1.M
	063d 0082 0bbe lri         $AR2, #0x0bbe
	063f 27d9      lrs         $AC1.M, @ACCAL
	0640 1adf      srrd        @$AR2, $AC1.M
	0641 27d8      lrs         $AC1.M, @ACCAH
	0642 1adf      srrd        @$AR2, $AC1.M
	0643 8f00      set40       
	0644 00c1 0e42 lr          $AR1, @0x0e42
	0646 0082 0d80 lri         $AR2, #0x0d80
	0648 1940      lrri        $AR0, @$AR2
	0649 1943      lrri        $AR3, @$AR2
	064a 80f0      nx'ld       : $AX0.H, $AX1.H, @$AR0
	064b b8c0      mulx'ld     $AX0.H, $AX1.H : $AX0.L, $AX1.L, @$AR0
	064c 111f 0654 bloopi      #0x1f, 0x0654
		064e a6f0      mulxmv'ld   $AX0.L, $AX1.L, $ACC0 : $AX0.H, $AX1.H, @$AR0
		064f bcf0      mulxac'ld   $AX0.H, $AX1.H, $ACC0 : $AX0.H, $AX1.H, @$AR0
		0650 1940      lrri        $AR0, @$AR2
		0651 1943      lrri        $AR3, @$AR2
		0652 bcf0      mulxac'ld   $AX0.H, $AX1.H, $ACC0 : $AX0.H, $AX1.H, @$AR0
		0653 4ec0      addp'ld     $ACC0 : $AX0.L, $AX1.L, @$AR0
		0654 b831      mulx's      $AX0.H, $AX1.H : @$AR1, $AC0.M
		
	0655 a6f0      mulxmv'ld   $AX0.L, $AX1.L, $ACC0 : $AX0.H, $AX1.H, @$AR0
	0656 bcf0      mulxac'ld   $AX0.H, $AX1.H, $ACC0 : $AX0.H, $AX1.H, @$AR0
	0657 bc00      mulxac      $AX0.H, $AX1.H, $ACC0
	0658 4e00      addp        $ACC0
	0659 1b3e      srri        @$AR1, $AC0.M
	065a 00e1 0e42 sr          @0x0e42, $AR1
	
	065c 02df      ret
}

void SRC_Linear() {
	// Copy pb's data [pb.addr.format to pb.adpm.yn2] to corresponding hw regs
	// 065d 0082 0bb8 lri         $AR2, #0x0bb8
	// 065f 195e      lrri        $AC0.M, @$AR2
	// 0660 2ed1      srs         @SampleFormat, $AC0.M
	// 0661 195e      lrri        $AC0.M, @$AR2
	// 0662 2ed4      srs         @ACSAH, $AC0.M
	// 0663 195e      lrri        $AC0.M, @$AR2
	// 0664 2ed5      srs         @ACSAL, $AC0.M
	// 0665 195e      lrri        $AC0.M, @$AR2
	// 0666 2ed6      srs         @ACEAH, $AC0.M
	// 0667 195e      lrri        $AC0.M, @$AR2
	// 0668 2ed7      srs         @ACEAL, $AC0.M
	// 0669 195e      lrri        $AC0.M, @$AR2
	// 066a 2ed8      srs         @ACCAH, $AC0.M
	// 066b 195e      lrri        $AC0.M, @$AR2
	// 066c 2ed9      srs         @ACCAL, $AC0.M
	// 066d 195e      lrri        $AC0.M, @$AR2
	// 066e 2ea0      srs         @COEF_A1_0, $AC0.M
	// 066f 195e      lrri        $AC0.M, @$AR2
	// 0670 2ea1      srs         @COEF_A2_0, $AC0.M
	// 0671 195e      lrri        $AC0.M, @$AR2
	// 0672 2ea2      srs         @COEF_A1_1, $AC0.M
	// 0673 195e      lrri        $AC0.M, @$AR2
	// 0674 2ea3      srs         @COEF_A2_1, $AC0.M
	// 0675 195e      lrri        $AC0.M, @$AR2
	// 0676 2ea4      srs         @COEF_A1_2, $AC0.M
	// 0677 195e      lrri        $AC0.M, @$AR2
	// 0678 2ea5      srs         @COEF_A2_2, $AC0.M
	// 0679 195e      lrri        $AC0.M, @$AR2
	// 067a 2ea6      srs         @COEF_A1_3, $AC0.M
	// 067b 195e      lrri        $AC0.M, @$AR2
	// 067c 2ea7      srs         @COEF_A2_3, $AC0.M
	// 067d 195e      lrri        $AC0.M, @$AR2
	// 067e 2ea8      srs         @COEF_A1_4, $AC0.M
	// 067f 195e      lrri        $AC0.M, @$AR2
	// 0680 2ea9      srs         @COEF_A2_4, $AC0.M
	// 0681 195e      lrri        $AC0.M, @$AR2
	// 0682 2eaa      srs         @COEF_A1_5, $AC0.M
	// 0683 195e      lrri        $AC0.M, @$AR2
	// 0684 2eab      srs         @COEF_A2_5, $AC0.M
	// 0685 195e      lrri        $AC0.M, @$AR2
	// 0686 2eac      srs         @COEF_A1_6, $AC0.M
	// 0687 195e      lrri        $AC0.M, @$AR2
	// 0688 2ead      srs         @COEF_A2_6, $AC0.M
	// 0689 195e      lrri        $AC0.M, @$AR2
	// 068a 2eae      srs         @COEF_A1_7, $AC0.M
	// 068b 195e      lrri        $AC0.M, @$AR2
	// 068c 2eaf      srs         @COEF_A2_7, $AC0.M
	// 068d 195e      lrri        $AC0.M, @$AR2
	// 068e 2ede      srs         @GAIN, $AC0.M
	// 068f 195e      lrri        $AC0.M, @$AR2
	// 0690 2eda      srs         @scale, $AC0.M
	// 0691 195e      lrri        $AC0.M, @$AR2
	// 0692 2edb      srs         @yn1, $AC0.M
	// 0693 195e      lrri        $AC0.M, @$AR2
	// 0694 2edc      srs         @yn2, $AC0.M
	
	// 0695 8c00      clr15       // signed mulx
	// 0696 8a00      m2          // *2
	// 0697 8e00      set16       // no sign extend
	
	// 0698 195b      lrri        $AX1.H, @$AR2
	// 0699 1959      lrri        $AX1.L, @$AR2
	// 069a 8100      clr         $ACC0
	// 069b 195c      lrri        $AC0.L, @$AR2
	// 069c 0080 0e44 lri         $AR0, #0x0e44
	// 069e 195f      lrri        $AC1.M, @$AR2
	// 069f 195f      lrri        $AC1.M, @$AR2
	// 06a0 195f      lrri        $AC1.M, @$AR2
	// 06a1 1b1f      srri        @$AR0, $AC1.M
	AR0 = 0x0e44
	AX1.H = pb.src.ratioHi
	AX1.L = pb.src.ratioLo
	AC0.L = pb.src.currentAddressFrac
	AC1.M = pb.src.last_samples[2]
	
	*0x0e44 = pb.src.last_samples[2]
	*0x0e45 = pb.src.last_samples[3]
	
	// 06a2 185f      lrr         $AC1.M, @$AR2
	// 06a3 1b1f      srri        @$AR0, $AC1.M
	// 06a4 6b00      movax       $ACC1, $AX1
	// 06a5 1505      lsl         $ACC1, #5
	// 06a6 4d00      add         $ACC1, $ACC0
	// 06a7 157e      lsr         $ACC1, #-2
	// 06a8 1c9f      mrr         $IX0, $AC1.M
	// 06a9 1cbd      mrr         $IX1, $AC1.L
	ACC1 = (pb.src.currentAddressFrac + (pb.src.ratio << 5)) >> 2
	IX0 = ACC1 >> 16
	IX1 = ((ACC1 & 0xffff) & 0xc000) >> 14
	IX2 = ~((ACC1 >> 16) - 32)
	AX0.H = 0x01fc
	AC0.M = 0x0e45
	AR1 = 0xffdd // DSP_ACCELERATOR
	AR3 = 0x0d80
	
	// 06aa 05e0      addis       $AC1.M, #0xe0
	// 06ab 9900      asr16       $ACC1
	// 06ac 7d00      neg         $ACC1
	// 06ad 1cdd      mrr         $IX2, $AC1.L
	// 06ae 8900      clr         $ACC1
	// 06af 1fa5      mrr         $AC1.L, $IX1
	// 06b0 1502      lsl         $ACC1, #2
	// 06b1 1cbf      mrr         $IX1, $AC1.M
	// 06b2 009a 01fc lri         $AX0.H, #0x01fc
	// 06b4 009e 0e45 lri         $AC0.M, #0x0e45
	// 06b6 0081 ffdd lri         $AR1, #0xffdd
	// 06b8 0083 0d80 lri         $AR3, #0x0d80
	// 06ba 0064 06cb bloop       $IX0, 0x06cb
	// 	06bc 1827      lrr         $IX3, @$AR1
	// 	06bd 1b07      srri        @$AR0, $IX3
	// 	06be 4a00      addax       $ACC0, $AX1
	// 	06bf 1b7e      srri        @$AR3, $AC0.M
	// 	06c0 1827      lrr         $IX3, @$AR1
	// 	06c1 1b07      srri        @$AR0, $IX3
	// 	06c2 1b7c      srri        @$AR3, $AC0.L
	// 	06c3 0000      nop         
	// 	06c4 1827      lrr         $IX3, @$AR1
	// 	06c5 1b07      srri        @$AR0, $IX3
	// 	06c6 0000      nop         
	// 	06c7 0000      nop         
	// 	06c8 1827      lrr         $IX3, @$AR1
	// 	06c9 1b07      srri        @$AR0, $IX3
	// 	06ca 0000      nop         
	// 	06cb 0000      nop         
	ACCO = (0x0e45 << 16) + pb.src.currentAddressFrac
	for (i = 0; i < IX0; i++) {
		ACC0 += pb.src.ratio
		*(0x0d80++) = ACC0 >> 16
		*(0x0d80++) = ACC0 & 0xffff
		*(0x0e46++) = *DSP_ACCELERATOR
		*(0x0e46++) = *DSP_ACCELERATOR
		*(0x0e46++) = *DSP_ACCELERATOR
		*(0x0e46++) = *DSP_ACCELERATOR
	}
		
	// 06cc 0065 06d1 bloop       $IX1, 0x06d1
	// 	06ce 1827      lrr         $IX3, @$AR1
	// 	06cf 1b07      srri        @$AR0, $IX3
	// 	06d0 0000      nop         
	// 	06d1 0000      nop         
	for (i = 0; i < IX1; i++) {
		*(0x0e46++) = *DSP_ACCELERATOR
	}
		
	// 06d2 0066 06d6 bloop       $IX2, 0x06d6
	// 	06d4 4a00      addax       $ACC0, $AX1
	// 	06d5 1b7e      srri        @$AR3, $AC0.M
	// 	06d6 1b7c      srri        @$AR3, $AC0.L
	for (i = 0; i < IX2; i++) {
		ACC0 += pb.src.ratio
		*(0x0d80++) = ACC0 >> 16
		*(0x0d80++) = ACC0 & 0xffff
	}
		
	// 06d7 0004      dar         $AR0
	// 06d8 189f      lrrd        $AC1.M, @$AR0
	// 06d9 1adf      srrd        @$AR2, $AC1.M
	// 06da 189f      lrrd        $AC1.M, @$AR0
	// 06db 1adf      srrd        @$AR2, $AC1.M
	// 06dc 189f      lrrd        $AC1.M, @$AR0
	// 06dd 1adf      srrd        @$AR2, $AC1.M
	// 06de 189f      lrrd        $AC1.M, @$AR0
	// 06df 1adf      srrd        @$AR2, $AC1.M
	// 06e0 1adc      srrd        @$AR2, $AC0.L
	*(0x0e46++)--
	pb.src.last_samples[3] = *(0x0e46--)
	pb.src.last_samples[2] = *(0x0e46--)
	pb.src.last_samples[1] = *(0x0e46--)
	pb.src.last_samples[0] = *(0x0e46--)
	pb.src.currentAddressFrac = ACC0 & 0xffff
	
	// 06e1 0082 0bd2 lri         $AR2, #0x0bd2
	// 06e3 27dc      lrs         $AC1.M, @yn2
	// 06e4 1adf      srrd        @$AR2, $AC1.M
	// 06e5 27db      lrs         $AC1.M, @yn1
	// 06e6 1adf      srrd        @$AR2, $AC1.M
	// 06e7 27da      lrs         $AC1.M, @scale
	// 06e8 1adf      srrd        @$AR2, $AC1.M
	// 06e9 0082 0bbe lri         $AR2, #0x0bbe
	// 06eb 27d9      lrs         $AC1.M, @ACCAL
	// 06ec 1adf      srrd        @$AR2, $AC1.M
	// 06ed 27d8      lrs         $AC1.M, @ACCAH
	// 06ee 1adf      srrd        @$AR2, $AC1.M
	pb.adpm.yn2 = *yn2
	pb.adpm.yn1 = *yn1
	pb.adpm.pred_scale = *scale
	pb.addr.currentAddressLo = *ACCAL // Current playback position
	pb.addr.currentAddressHi = *ACCAH
	
	06ef 8d00      set15       // unsigned mulx
	06f0 8b00      m0          // no *2
	06f1 8f00      set40       // sign extend
	06f2 00c1 0e42 lr          $AR1, @0x0e42
	06f4 0082 0d80 lri         $AR2, #0x0d80
	06f6 8100      clr         $ACC0
	06f7 1120 0703 bloopi      #0x20, 0x0703
		06f9 8900      clr         $ACC1
		06fa 1940      lrri        $AR0, @$AR2
		06fb 189e      lrrd        $AC0.M, @$AR0
		06fc 181b      lrr         $AX1.H, @$AR0
		06fd 199a      lrrn        $AX0.H, @$AR0
		06fe 5400      subr        $ACC0, $AX0.H
		06ff 1f5e      mrr         $AX0.H, $AC0.M
		0700 1959      lrri        $AX1.L, @$AR2
		0701 b000      mulx        $AX0.H, $AX1.L
		0702 fb00      addpaxz     $ACC1, $AX1
		0703 8139      clr's       $ACC0 : @$AR1, $AC1.M
		
	0704 00e1 0e42 sr          @0x0e42, $AR1
	
	0706 02df      ret
}

void SRC_None() {
	// Copy pb's data [pb.addr.format to pb.adpm.yn2] to corresponding hw regs
	// 0707 0082 0bb8 lri         $AR2, #0x0bb8
	// 0709 195e      lrri        $AC0.M, @$AR2
	// 070a 2ed1      srs         @SampleFormat, $AC0.M
	// 070b 195e      lrri        $AC0.M, @$AR2
	// 070c 2ed4      srs         @ACSAH, $AC0.M
	// 070d 195e      lrri        $AC0.M, @$AR2
	// 070e 2ed5      srs         @ACSAL, $AC0.M
	// 070f 195e      lrri        $AC0.M, @$AR2
	// 0710 2ed6      srs         @ACEAH, $AC0.M
	// 0711 195e      lrri        $AC0.M, @$AR2
	// 0712 2ed7      srs         @ACEAL, $AC0.M
	// 0713 195e      lrri        $AC0.M, @$AR2
	// 0714 2ed8      srs         @ACCAH, $AC0.M
	// 0715 195e      lrri        $AC0.M, @$AR2
	// 0716 2ed9      srs         @ACCAL, $AC0.M
	// 0717 195e      lrri        $AC0.M, @$AR2
	// 0718 2ea0      srs         @COEF_A1_0, $AC0.M
	// 0719 195e      lrri        $AC0.M, @$AR2
	// 071a 2ea1      srs         @COEF_A2_0, $AC0.M
	// 071b 195e      lrri        $AC0.M, @$AR2
	// 071c 2ea2      srs         @COEF_A1_1, $AC0.M
	// 071d 195e      lrri        $AC0.M, @$AR2
	// 071e 2ea3      srs         @COEF_A2_1, $AC0.M
	// 071f 195e      lrri        $AC0.M, @$AR2
	// 0720 2ea4      srs         @COEF_A1_2, $AC0.M
	// 0721 195e      lrri        $AC0.M, @$AR2
	// 0722 2ea5      srs         @COEF_A2_2, $AC0.M
	// 0723 195e      lrri        $AC0.M, @$AR2
	// 0724 2ea6      srs         @COEF_A1_3, $AC0.M
	// 0725 195e      lrri        $AC0.M, @$AR2
	// 0726 2ea7      srs         @COEF_A2_3, $AC0.M
	// 0727 195e      lrri        $AC0.M, @$AR2
	// 0728 2ea8      srs         @COEF_A1_4, $AC0.M
	// 0729 195e      lrri        $AC0.M, @$AR2
	// 072a 2ea9      srs         @COEF_A2_4, $AC0.M
	// 072b 195e      lrri        $AC0.M, @$AR2
	// 072c 2eaa      srs         @COEF_A1_5, $AC0.M
	// 072d 195e      lrri        $AC0.M, @$AR2
	// 072e 2eab      srs         @COEF_A2_5, $AC0.M
	// 072f 195e      lrri        $AC0.M, @$AR2
	// 0730 2eac      srs         @COEF_A1_6, $AC0.M
	// 0731 195e      lrri        $AC0.M, @$AR2
	// 0732 2ead      srs         @COEF_A2_6, $AC0.M
	// 0733 195e      lrri        $AC0.M, @$AR2
	// 0734 2eae      srs         @COEF_A1_7, $AC0.M
	// 0735 195e      lrri        $AC0.M, @$AR2
	// 0736 2eaf      srs         @COEF_A2_7, $AC0.M
	// 0737 195e      lrri        $AC0.M, @$AR2
	// 0738 2ede      srs         @GAIN, $AC0.M
	// 0739 195e      lrri        $AC0.M, @$AR2
	// 073a 2eda      srs         @scale, $AC0.M
	// 073b 195e      lrri        $AC0.M, @$AR2
	// 073c 2edb      srs         @yn1, $AC0.M
	// 073d 195e      lrri        $AC0.M, @$AR2
	// 073e 2edc      srs         @yn2, $AC0.M
	
	// 073f 00c0 0e42 lr          $AR0, @0x0e42
	// 0741 0081 ffdd lri         $AR1, #0xffdd // DSP_ACCELERATOR
	// 0743 1120 0748 bloopi      #0x20, 0x0748
	// 	0745 1824      lrr         $IX0, @$AR1
	// 	0746 1b04      srri        @$AR0, $IX0
	// 	0747 0000      nop         
	// 	0748 0000      nop         
	// 0749 00e0 0e42 sr          @0x0e42, $AR0
	
	u16 i = *0x0e42
	for (; i < ((*0x0e42) + 0x20); i++) {
		*i = *DSP_ACCELERATOR
	}
	*0x0e42 = i
	
	// 074b 0082 0bd9 lri         $AR2, #0x0bd9 // pb.src.last_samples[3]
	// 074d 0004      dar         $AR0
	// 074e 189f      lrrd        $AC1.M, @$AR0
	// 074f 1adf      srrd        @$AR2, $AC1.M
	// 0750 189f      lrrd        $AC1.M, @$AR0
	// 0751 1adf      srrd        @$AR2, $AC1.M
	// 0752 189f      lrrd        $AC1.M, @$AR0
	// 0753 1adf      srrd        @$AR2, $AC1.M
	// 0754 189f      lrrd        $AC1.M, @$AR0
	// 0755 1adf      srrd        @$AR2, $AC1.M
	// 0756 8900      clr         $ACC1
	// 0757 1adc      srrd        @$AR2, $AC0.L // uhhh assume AC0.L is 0?
	i-- // Guess that 0x0e42 points to struct of 1 pointer and 32 values
	pb.src.last_samples[3] = *(i--)
	pb.src.last_samples[2] = *(i--)
	pb.src.last_samples[1] = *(i--)
	pb.src.last_samples[0] = *(i--)
	pb.src.currentAddressFrac = 0
	
	// 0758 27dc      lrs         $AC1.M, @yn2
	// 0759 00ff 0bd2 sr          @0x0bd2, $AC1.M
	// 075b 27db      lrs         $AC1.M, @yn1
	// 075c 00ff 0bd1 sr          @0x0bd1, $AC1.M
	// 075e 27da      lrs         $AC1.M, @scale
	// 075f 00ff 0bd0 sr          @0x0bd0, $AC1.M
	// 0761 27d9      lrs         $AC1.M, @ACCAL
	// 0762 00ff 0bbe sr          @0x0bbe, $AC1.M
	// 0764 27d8      lrs         $AC1.M, @ACCAH
	// 0765 00ff 0bbd sr          @0x0bbd, $AC1.M
	pb.adpm.yn2 = *yn2
	pb.adpm.yn1 = *yn1
	pb.adpm.pred_scale = *scale
	pb.addr.currentAddressLo = *ACCAL // Current playback position
	pb.addr.currentAddressHi = *ACCAH
	
	0767 02df      ret
}


# From here to the jump tables, all the funcs just wrap calls to mixer(s) in IROM

void Mixer_0() {
	0768 00c0 0e40 lr          $AR0, @0x0e40
	076a 0081 0b89 lri         $AR1, #0x0b89
	076c 00c2 0e08 lr          $AR2, @0x0e08
	076e 1c62      mrr         $AR3, $AR2
	076f 00c4 0e41 lr          $IX0, @0x0e41
	0771 00c5 0e09 lr          $IX1, @0x0e09
	0773 02bf 80e7 call        0x80e7
	0775 00f8 0ba9 sr          @0x0ba9, $AX0.L
	0777 00fb 0bac sr          @0x0bac, $AX1.H
	0779 02df      ret
}

void Mixer_1() {
	077a 00c0 0e40 lr          $AR0, @0x0e40
	077c 0081 0b89 lri         $AR1, #0x0b89
	077e 00c2 0e08 lr          $AR2, @0x0e08
	0780 1c62      mrr         $AR3, $AR2
	0781 00c4 0e41 lr          $IX0, @0x0e41
	0783 00c5 0e09 lr          $IX1, @0x0e09
	0785 02bf 80e7 call        0x80e7
	0787 00f8 0ba9 sr          @0x0ba9, $AX0.L
	0789 00fb 0bac sr          @0x0bac, $AX1.H
	078b 00c0 0e40 lr          $AR0, @0x0e40
	078d 0081 0b8d lri         $AR1, #0x0b8d
	078f 00c2 0e0b lr          $AR2, @0x0e0b
	0791 1c62      mrr         $AR3, $AR2
	0792 00c4 0e41 lr          $IX0, @0x0e41
	0794 00c5 0e0c lr          $IX1, @0x0e0c
	0796 02bf 80e7 call        0x80e7
	0798 00f8 0baa sr          @0x0baa, $AX0.L
	079a 00fb 0bad sr          @0x0bad, $AX1.H
	079c 02df      ret
}

void Mixer_2() {
	079d 00c0 0e40 lr          $AR0, @0x0e40
	079f 0081 0b89 lri         $AR1, #0x0b89
	07a1 00c2 0e08 lr          $AR2, @0x0e08
	07a3 1c62      mrr         $AR3, $AR2
	07a4 00c4 0e41 lr          $IX0, @0x0e41
	07a6 00c5 0e09 lr          $IX1, @0x0e09
	07a8 02bf 80e7 call        0x80e7
	07aa 00f8 0ba9 sr          @0x0ba9, $AX0.L
	07ac 00fb 0bac sr          @0x0bac, $AX1.H
	07ae 00c0 0e40 lr          $AR0, @0x0e40
	07b0 0081 0b91 lri         $AR1, #0x0b91
	07b2 00c2 0e0e lr          $AR2, @0x0e0e
	07b4 1c62      mrr         $AR3, $AR2
	07b5 00c4 0e41 lr          $IX0, @0x0e41
	07b7 00c5 0e0f lr          $IX1, @0x0e0f
	07b9 02bf 80e7 call        0x80e7
	07bb 00f8 0bab sr          @0x0bab, $AX0.L
	07bd 00fb 0bae sr          @0x0bae, $AX1.H
	07bf 02df      ret
}

void Unk() {
	07c0 00c0 0e40 lr          $AR0, @0x0e40
	07c2 0081 0b89 lri         $AR1, #0x0b89
	07c4 00c2 0e08 lr          $AR2, @0x0e08
	07c6 1c62      mrr         $AR3, $AR2
	07c7 00c4 0e41 lr          $IX0, @0x0e41
	07c9 00c5 0e09 lr          $IX1, @0x0e09
	07cb 02bf 80e7 call        0x80e7
	07cd 00f8 0ba9 sr          @0x0ba9, $AX0.L
	07cf 00fb 0bac sr          @0x0bac, $AX1.H
	07d1 00c0 0e40 lr          $AR0, @0x0e40
	07d3 0081 0b8d lri         $AR1, #0x0b8d
	07d5 00c2 0e0b lr          $AR2, @0x0e0b
	07d7 1c62      mrr         $AR3, $AR2
	07d8 00c4 0e41 lr          $IX0, @0x0e41
	07da 00c5 0e0c lr          $IX1, @0x0e0c
	07dc 02bf 80e7 call        0x80e7
	07de 00f8 0baa sr          @0x0baa, $AX0.L
	07e0 00fb 0bad sr          @0x0bad, $AX1.H
	07e2 00c0 0e40 lr          $AR0, @0x0e40
	07e4 0081 0b91 lri         $AR1, #0x0b91
	07e6 00c2 0e0e lr          $AR2, @0x0e0e
	07e8 1c62      mrr         $AR3, $AR2
	07e9 00c4 0e41 lr          $IX0, @0x0e41
	07eb 00c5 0e0f lr          $IX1, @0x0e0f
	07ed 02bf 80e7 call        0x80e7
	07ef 00f8 0bab sr          @0x0bab, $AX0.L
	07f1 00fb 0bae sr          @0x0bae, $AX1.H
	07f3 02df      ret
}

void Unk() {
	07f4 00c0 0e40 lr          $AR0, @0x0e40
	07f6 0081 0b89 lri         $AR1, #0x0b89
	07f8 00c2 0e08 lr          $AR2, @0x0e08
	07fa 1c62      mrr         $AR3, $AR2
	07fb 00c4 0e41 lr          $IX0, @0x0e41
	07fd 00c5 0e09 lr          $IX1, @0x0e09
	07ff 02bf 80e7 call        0x80e7
	0801 00f8 0ba9 sr          @0x0ba9, $AX0.L
	0803 00fb 0bac sr          @0x0bac, $AX1.H
	0805 00c0 0e43 lr          $AR0, @0x0e43
	0807 0081 0b97 lri         $AR1, #0x0b97
	0809 00c2 0e0a lr          $AR2, @0x0e0a
	080b 1c62      mrr         $AR3, $AR2
	080c 02bf 81f9 call        0x81f9
	080e 00f8 0baf sr          @0x0baf, $AX0.L
	0810 02df      ret
}

void Unk() {
	0811 00c0 0e40 lr          $AR0, @0x0e40
	0813 0081 0b89 lri         $AR1, #0x0b89
	0815 00c2 0e08 lr          $AR2, @0x0e08
	0817 1c62      mrr         $AR3, $AR2
	0818 00c4 0e41 lr          $IX0, @0x0e41
	081a 00c5 0e09 lr          $IX1, @0x0e09
	081c 02bf 80e7 call        0x80e7
	081e 00f8 0ba9 sr          @0x0ba9, $AX0.L
	0820 00fb 0bac sr          @0x0bac, $AX1.H
	0822 00c0 0e40 lr          $AR0, @0x0e40
	0824 0081 0b8d lri         $AR1, #0x0b8d
	0826 00c2 0e0b lr          $AR2, @0x0e0b
	0828 1c62      mrr         $AR3, $AR2
	0829 00c4 0e41 lr          $IX0, @0x0e41
	082b 00c5 0e0c lr          $IX1, @0x0e0c
	082d 02bf 80e7 call        0x80e7
	082f 00f8 0baa sr          @0x0baa, $AX0.L
	0831 00fb 0bad sr          @0x0bad, $AX1.H
	0833 00c0 0e43 lr          $AR0, @0x0e43
	0835 0081 0b97 lri         $AR1, #0x0b97
	0837 00c2 0e0a lr          $AR2, @0x0e0a
	0839 1c62      mrr         $AR3, $AR2
	083a 1c80      mrr         $IX0, $AR0
	083b 00c5 0e0d lr          $IX1, @0x0e0d
	083d 02bf 80e7 call        0x80e7
	083f 00f8 0baf sr          @0x0baf, $AX0.L
	0841 00fb 0bb0 sr          @0x0bb0, $AX1.H
	0843 02df      ret
}

void Unk() {
	0844 00c0 0e40 lr          $AR0, @0x0e40
	0846 0081 0b89 lri         $AR1, #0x0b89
	0848 00c2 0e08 lr          $AR2, @0x0e08
	084a 1c62      mrr         $AR3, $AR2
	084b 00c4 0e41 lr          $IX0, @0x0e41
	084d 00c5 0e09 lr          $IX1, @0x0e09
	084f 02bf 80e7 call        0x80e7
	0851 00f8 0ba9 sr          @0x0ba9, $AX0.L
	0853 00fb 0bac sr          @0x0bac, $AX1.H
	0855 00c0 0e40 lr          $AR0, @0x0e40
	0857 0081 0b91 lri         $AR1, #0x0b91
	0859 00c2 0e0e lr          $AR2, @0x0e0e
	085b 1c62      mrr         $AR3, $AR2
	085c 00c4 0e41 lr          $IX0, @0x0e41
	085e 00c5 0e0f lr          $IX1, @0x0e0f
	0860 02bf 80e7 call        0x80e7
	0862 00f8 0bab sr          @0x0bab, $AX0.L
	0864 00fb 0bae sr          @0x0bae, $AX1.H
	0866 00c0 0e43 lr          $AR0, @0x0e43
	0868 0081 0b95 lri         $AR1, #0x0b95
	086a 00c2 0e10 lr          $AR2, @0x0e10
	086c 1c62      mrr         $AR3, $AR2
	086d 1c80      mrr         $IX0, $AR0
	086e 00c5 0e0a lr          $IX1, @0x0e0a
	0870 02bf 80e7 call        0x80e7
	0872 00f8 0bb1 sr          @0x0bb1, $AX0.L
	0874 00fb 0baf sr          @0x0baf, $AX1.H
	0876 02df      ret
}

void Unk() {
	0877 00c0 0e40 lr          $AR0, @0x0e40
	0879 0081 0b89 lri         $AR1, #0x0b89
	087b 00c2 0e08 lr          $AR2, @0x0e08
	087d 1c62      mrr         $AR3, $AR2
	087e 00c4 0e41 lr          $IX0, @0x0e41
	0880 00c5 0e09 lr          $IX1, @0x0e09
	0882 02bf 80e7 call        0x80e7
	0884 00f8 0ba9 sr          @0x0ba9, $AX0.L
	0886 00fb 0bac sr          @0x0bac, $AX1.H
	0888 00c0 0e40 lr          $AR0, @0x0e40
	088a 0081 0b8d lri         $AR1, #0x0b8d
	088c 00c2 0e0b lr          $AR2, @0x0e0b
	088e 1c62      mrr         $AR3, $AR2
	088f 00c4 0e41 lr          $IX0, @0x0e41
	0891 00c5 0e0c lr          $IX1, @0x0e0c
	0893 02bf 80e7 call        0x80e7
	0895 00f8 0baa sr          @0x0baa, $AX0.L
	0897 00fb 0bad sr          @0x0bad, $AX1.H
	0899 00c0 0e40 lr          $AR0, @0x0e40
	089b 0081 0b91 lri         $AR1, #0x0b91
	089d 00c2 0e0e lr          $AR2, @0x0e0e
	089f 1c62      mrr         $AR3, $AR2
	08a0 00c4 0e41 lr          $IX0, @0x0e41
	08a2 00c5 0e0f lr          $IX1, @0x0e0f
	08a4 02bf 80e7 call        0x80e7
	08a6 00f8 0bab sr          @0x0bab, $AX0.L
	08a8 00fb 0bae sr          @0x0bae, $AX1.H
	08aa 00c0 0e43 lr          $AR0, @0x0e43
	08ac 0081 0b97 lri         $AR1, #0x0b97
	08ae 00c2 0e0a lr          $AR2, @0x0e0a
	08b0 1c62      mrr         $AR3, $AR2
	08b1 1c80      mrr         $IX0, $AR0
	08b2 00c5 0e0d lr          $IX1, @0x0e0d
	08b4 02bf 80e7 call        0x80e7
	08b6 00f8 0baf sr          @0x0baf, $AX0.L
	08b8 00fb 0bb0 sr          @0x0bb0, $AX1.H
	08ba 00c0 0e43 lr          $AR0, @0x0e43
	08bc 0081 0b95 lri         $AR1, #0x0b95
	08be 00c2 0e10 lr          $AR2, @0x0e10
	08c0 1c62      mrr         $AR3, $AR2
	08c1 02bf 81f9 call        0x81f9
	08c3 00f8 0bb1 sr          @0x0bb1, $AX0.L
	08c5 02df      ret
}

void Unk() {
	08c6 00c0 0e40 lr          $AR0, @0x0e40
	08c8 0081 0b89 lri         $AR1, #0x0b89
	08ca 00c2 0e08 lr          $AR2, @0x0e08
	08cc 0083 0e44 lri         $AR3, #0x0e44
	08ce 00c4 0e41 lr          $IX0, @0x0e41
	08d0 00c5 0e09 lr          $IX1, @0x0e09
	08d2 02bf 8282 call        0x8282
	08d4 00f8 0ba9 sr          @0x0ba9, $AX0.L
	08d6 00fb 0bac sr          @0x0bac, $AX1.H
	08d8 02df      ret
}

void Unk() {
	08d9 00c0 0e40 lr          $AR0, @0x0e40
	08db 0081 0b89 lri         $AR1, #0x0b89
	08dd 00c2 0e08 lr          $AR2, @0x0e08
	08df 0083 0e44 lri         $AR3, #0x0e44
	08e1 00c4 0e41 lr          $IX0, @0x0e41
	08e3 00c5 0e09 lr          $IX1, @0x0e09
	08e5 02bf 8282 call        0x8282
	08e7 00f8 0ba9 sr          @0x0ba9, $AX0.L
	08e9 00fb 0bac sr          @0x0bac, $AX1.H
	08eb 00c0 0e40 lr          $AR0, @0x0e40
	08ed 0081 0b8d lri         $AR1, #0x0b8d
	08ef 00c2 0e0b lr          $AR2, @0x0e0b
	08f1 0083 0e44 lri         $AR3, #0x0e44
	08f3 00c4 0e41 lr          $IX0, @0x0e41
	08f5 00c5 0e0c lr          $IX1, @0x0e0c
	08f7 02bf 8282 call        0x8282
	08f9 00f8 0baa sr          @0x0baa, $AX0.L
	08fb 00fb 0bad sr          @0x0bad, $AX1.H
	08fd 02df      ret
}

void Unk() {
	08fe 00c0 0e40 lr          $AR0, @0x0e40
	0900 0081 0b89 lri         $AR1, #0x0b89
	0902 00c2 0e08 lr          $AR2, @0x0e08
	0904 0083 0e44 lri         $AR3, #0x0e44
	0906 00c4 0e41 lr          $IX0, @0x0e41
	0908 00c5 0e09 lr          $IX1, @0x0e09
	090a 02bf 8282 call        0x8282
	090c 00f8 0ba9 sr          @0x0ba9, $AX0.L
	090e 00fb 0bac sr          @0x0bac, $AX1.H
	0910 00c0 0e40 lr          $AR0, @0x0e40
	0912 0081 0b91 lri         $AR1, #0x0b91
	0914 00c2 0e0e lr          $AR2, @0x0e0e
	0916 0083 0e44 lri         $AR3, #0x0e44
	0918 00c4 0e41 lr          $IX0, @0x0e41
	091a 00c5 0e0f lr          $IX1, @0x0e0f
	091c 02bf 8282 call        0x8282
	091e 00f8 0bab sr          @0x0bab, $AX0.L
	0920 00fb 0bae sr          @0x0bae, $AX1.H
	0922 02df      ret
}

void Unk() {
	0923 00c0 0e40 lr          $AR0, @0x0e40
	0925 0081 0b89 lri         $AR1, #0x0b89
	0927 00c2 0e08 lr          $AR2, @0x0e08
	0929 0083 0e44 lri         $AR3, #0x0e44
	092b 00c4 0e41 lr          $IX0, @0x0e41
	092d 00c5 0e09 lr          $IX1, @0x0e09
	092f 02bf 8282 call        0x8282
	0931 00f8 0ba9 sr          @0x0ba9, $AX0.L
	0933 00fb 0bac sr          @0x0bac, $AX1.H
	0935 00c0 0e40 lr          $AR0, @0x0e40
	0937 0081 0b8d lri         $AR1, #0x0b8d
	0939 00c2 0e0b lr          $AR2, @0x0e0b
	093b 0083 0e44 lri         $AR3, #0x0e44
	093d 00c4 0e41 lr          $IX0, @0x0e41
	093f 00c5 0e0c lr          $IX1, @0x0e0c
	0941 02bf 8282 call        0x8282
	0943 00f8 0baa sr          @0x0baa, $AX0.L
	0945 00fb 0bad sr          @0x0bad, $AX1.H
	0947 00c0 0e40 lr          $AR0, @0x0e40
	0949 0081 0b91 lri         $AR1, #0x0b91
	094b 00c2 0e0e lr          $AR2, @0x0e0e
	094d 0083 0e44 lri         $AR3, #0x0e44
	094f 00c4 0e41 lr          $IX0, @0x0e41
	0951 00c5 0e0f lr          $IX1, @0x0e0f
	0953 02bf 8282 call        0x8282
	0955 00f8 0bab sr          @0x0bab, $AX0.L
	0957 00fb 0bae sr          @0x0bae, $AX1.H
	0959 02df      ret
}

void Unk() {
	095a 00c0 0e40 lr          $AR0, @0x0e40
	095c 0081 0b89 lri         $AR1, #0x0b89
	095e 00c2 0e08 lr          $AR2, @0x0e08
	0960 0083 0e44 lri         $AR3, #0x0e44
	0962 00c4 0e41 lr          $IX0, @0x0e41
	0964 00c5 0e09 lr          $IX1, @0x0e09
	0966 02bf 8282 call        0x8282
	0968 00f8 0ba9 sr          @0x0ba9, $AX0.L
	096a 00fb 0bac sr          @0x0bac, $AX1.H
	096c 00c0 0e43 lr          $AR0, @0x0e43
	096e 0081 0b97 lri         $AR1, #0x0b97
	0970 00c2 0e0a lr          $AR2, @0x0e0a
	0972 0083 0e44 lri         $AR3, #0x0e44
	0974 02bf 845d call        0x845d
	0976 00f8 0baf sr          @0x0baf, $AX0.L
	0978 02df      ret
}

void Unk() {
	0979 00c0 0e40 lr          $AR0, @0x0e40
	097b 0081 0b89 lri         $AR1, #0x0b89
	097d 00c2 0e08 lr          $AR2, @0x0e08
	097f 0083 0e44 lri         $AR3, #0x0e44
	0981 00c4 0e41 lr          $IX0, @0x0e41
	0983 00c5 0e09 lr          $IX1, @0x0e09
	0985 02bf 8282 call        0x8282
	0987 00f8 0ba9 sr          @0x0ba9, $AX0.L
	0989 00fb 0bac sr          @0x0bac, $AX1.H
	098b 00c0 0e40 lr          $AR0, @0x0e40
	098d 0081 0b8d lri         $AR1, #0x0b8d
	098f 00c2 0e0b lr          $AR2, @0x0e0b
	0991 0083 0e44 lri         $AR3, #0x0e44
	0993 00c4 0e41 lr          $IX0, @0x0e41
	0995 00c5 0e0c lr          $IX1, @0x0e0c
	0997 02bf 8282 call        0x8282
	0999 00f8 0baa sr          @0x0baa, $AX0.L
	099b 00fb 0bad sr          @0x0bad, $AX1.H
	099d 00c0 0e43 lr          $AR0, @0x0e43
	099f 0081 0b97 lri         $AR1, #0x0b97
	09a1 00c2 0e0a lr          $AR2, @0x0e0a
	09a3 0083 0e44 lri         $AR3, #0x0e44
	09a5 1c80      mrr         $IX0, $AR0
	09a6 00c5 0e0d lr          $IX1, @0x0e0d
	09a8 02bf 8282 call        0x8282
	09aa 00f8 0baf sr          @0x0baf, $AX0.L
	09ac 00fb 0bb0 sr          @0x0bb0, $AX1.H
	09ae 02df      ret
}

void Unk() {
	09af 00c0 0e40 lr          $AR0, @0x0e40
	09b1 0081 0b89 lri         $AR1, #0x0b89
	09b3 00c2 0e08 lr          $AR2, @0x0e08
	09b5 0083 0e44 lri         $AR3, #0x0e44
	09b7 00c4 0e41 lr          $IX0, @0x0e41
	09b9 00c5 0e09 lr          $IX1, @0x0e09
	09bb 02bf 8282 call        0x8282
	09bd 00f8 0ba9 sr          @0x0ba9, $AX0.L
	09bf 00fb 0bac sr          @0x0bac, $AX1.H
	09c1 00c0 0e40 lr          $AR0, @0x0e40
	09c3 0081 0b91 lri         $AR1, #0x0b91
	09c5 00c2 0e0e lr          $AR2, @0x0e0e
	09c7 0083 0e44 lri         $AR3, #0x0e44
	09c9 00c4 0e41 lr          $IX0, @0x0e41
	09cb 00c5 0e0f lr          $IX1, @0x0e0f
	09cd 02bf 8282 call        0x8282
	09cf 00f8 0bab sr          @0x0bab, $AX0.L
	09d1 00fb 0bae sr          @0x0bae, $AX1.H
	09d3 00c0 0e43 lr          $AR0, @0x0e43
	09d5 0081 0b95 lri         $AR1, #0x0b95
	09d7 00c2 0e10 lr          $AR2, @0x0e10
	09d9 0083 0e44 lri         $AR3, #0x0e44
	09db 1c80      mrr         $IX0, $AR0
	09dc 00c5 0e0a lr          $IX1, @0x0e0a
	09de 02bf 8282 call        0x8282
	09e0 00f8 0bb1 sr          @0x0bb1, $AX0.L
	09e2 00fb 0baf sr          @0x0baf, $AX1.H
	09e4 02df      ret
}

void Unk() {
	09e5 00c0 0e40 lr          $AR0, @0x0e40
	09e7 0081 0b89 lri         $AR1, #0x0b89
	09e9 00c2 0e08 lr          $AR2, @0x0e08
	09eb 0083 0e44 lri         $AR3, #0x0e44
	09ed 00c4 0e41 lr          $IX0, @0x0e41
	09ef 00c5 0e09 lr          $IX1, @0x0e09
	09f1 02bf 8282 call        0x8282
	09f3 00f8 0ba9 sr          @0x0ba9, $AX0.L
	09f5 00fb 0bac sr          @0x0bac, $AX1.H
	09f7 00c0 0e40 lr          $AR0, @0x0e40
	09f9 0081 0b8d lri         $AR1, #0x0b8d
	09fb 00c2 0e0b lr          $AR2, @0x0e0b
	09fd 0083 0e44 lri         $AR3, #0x0e44
	09ff 00c0 0e41 lr          $AR0, @0x0e41
	0a01 00c5 0e0c lr          $IX1, @0x0e0c
	0a03 02bf 8282 call        0x8282
	0a05 00f8 0baa sr          @0x0baa, $AX0.L
	0a07 00fb 0bad sr          @0x0bad, $AX1.H
	0a09 00c0 0e40 lr          $AR0, @0x0e40
	0a0b 0081 0b91 lri         $AR1, #0x0b91
	0a0d 00c2 0e0e lr          $AR2, @0x0e0e
	0a0f 0083 0e44 lri         $AR3, #0x0e44
	0a11 00c4 0e41 lr          $IX0, @0x0e41
	0a13 00c5 0e0f lr          $IX1, @0x0e0f
	0a15 02bf 8282 call        0x8282
	0a17 00f8 0bab sr          @0x0bab, $AX0.L
	0a19 00fb 0bae sr          @0x0bae, $AX1.H
	0a1b 00c0 0e43 lr          $AR0, @0x0e43
	0a1d 0081 0b97 lri         $AR1, #0x0b97
	0a1f 00c2 0e0a lr          $AR2, @0x0e0a
	0a21 0083 0e44 lri         $AR3, #0x0e44
	0a23 1c80      mrr         $IX0, $AR0
	0a24 00c5 0e0d lr          $IX1, @0x0e0d
	0a26 02bf 8282 call        0x8282
	0a28 00f8 0baf sr          @0x0baf, $AX0.L
	0a2a 00fb 0bb0 sr          @0x0bb0, $AX1.H
	0a2c 00c0 0e43 lr          $AR0, @0x0e43
	0a2e 0081 0b95 lri         $AR1, #0x0b95
	0a30 00c2 0e10 lr          $AR2, @0x0e10
	0a32 0083 0e44 lri         $AR3, #0x0e44
	0a34 02bf 845d call        0x845d
	0a36 00f8 0bb1 sr          @0x0bb1, $AX0.L
	0a38 02df      ret
}

void Unk() {
	0a39 00c0 0e40 lr          $AR0, @0x0e40
	0a3b 0081 0b89 lri         $AR1, #0x0b89
	0a3d 00c2 0e08 lr          $AR2, @0x0e08
	0a3f 1c62      mrr         $AR3, $AR2
	0a40 00c4 0e41 lr          $IX0, @0x0e41
	0a42 00c5 0e09 lr          $IX1, @0x0e09
	0a44 02bf 80e7 call        0x80e7
	0a46 00f8 0ba9 sr          @0x0ba9, $AX0.L
	0a48 00fb 0bac sr          @0x0bac, $AX1.H
	0a4a 00c0 0e43 lr          $AR0, @0x0e43
	0a4c 0081 0b91 lri         $AR1, #0x0b91
	0a4e 00c2 0e0e lr          $AR2, @0x0e0e
	0a50 1c62      mrr         $AR3, $AR2
	0a51 1c80      mrr         $IX0, $AR0
	0a52 00c5 0e0f lr          $IX1, @0x0e0f
	0a54 02bf 80e7 call        0x80e7
	0a56 00f8 0bab sr          @0x0bab, $AX0.L
	0a58 00fb 0bae sr          @0x0bae, $AX1.H
	0a5a 02df      ret
}

void Unk() {
	0a5b 00c0 0e40 lr          $AR0, @0x0e40
	0a5d 0081 0b89 lri         $AR1, #0x0b89
	0a5f 00c2 0e08 lr          $AR2, @0x0e08
	0a61 1c62      mrr         $AR3, $AR2
	0a62 00c4 0e41 lr          $IX0, @0x0e41
	0a64 00c5 0e09 lr          $IX1, @0x0e09
	0a66 02bf 80e7 call        0x80e7
	0a68 00f8 0ba9 sr          @0x0ba9, $AX0.L
	0a6a 00fb 0bac sr          @0x0bac, $AX1.H
	0a6c 00c0 0e43 lr          $AR0, @0x0e43
	0a6e 0081 0b91 lri         $AR1, #0x0b91
	0a70 00c2 0e0e lr          $AR2, @0x0e0e
	0a72 1c62      mrr         $AR3, $AR2
	0a73 1c80      mrr         $IX0, $AR0
	0a74 00c5 0e0f lr          $IX1, @0x0e0f
	0a76 02bf 80e7 call        0x80e7
	0a78 00f8 0bab sr          @0x0bab, $AX0.L
	0a7a 00fb 0bae sr          @0x0bae, $AX1.H
	0a7c 00c0 0e40 lr          $AR0, @0x0e40
	0a7e 0081 0b8d lri         $AR1, #0x0b8d
	0a80 00c2 0e0b lr          $AR2, @0x0e0b
	0a82 1c62      mrr         $AR3, $AR2
	0a83 00c4 0e41 lr          $IX0, @0x0e41
	0a85 00c5 0e0c lr          $IX1, @0x0e0c
	0a87 02bf 80e7 call        0x80e7
	0a89 00f8 0baa sr          @0x0baa, $AX0.L
	0a8b 00fb 0bad sr          @0x0bad, $AX1.H
	0a8d 00c0 0e43 lr          $AR0, @0x0e43
	0a8f 0081 0b99 lri         $AR1, #0x0b99
	0a91 00c2 0e0d lr          $AR2, @0x0e0d
	0a93 1c62      mrr         $AR3, $AR2
	0a94 02bf 81f9 call        0x81f9
	0a96 00f8 0bb0 sr          @0x0bb0, $AX0.L
	0a98 02df      ret
}

void Unk() {
	0a99 00c0 0e40 lr          $AR0, @0x0e40
	0a9b 0081 0b89 lri         $AR1, #0x0b89
	0a9d 00c2 0e08 lr          $AR2, @0x0e08
	0a9f 0083 0e44 lri         $AR3, #0x0e44
	0aa1 00c4 0e41 lr          $IX0, @0x0e41
	0aa3 00c5 0e09 lr          $IX1, @0x0e09
	0aa5 02bf 8282 call        0x8282
	0aa7 00f8 0ba9 sr          @0x0ba9, $AX0.L
	0aa9 00fb 0bac sr          @0x0bac, $AX1.H
	0aab 00c0 0e43 lr          $AR0, @0x0e43
	0aad 0081 0b91 lri         $AR1, #0x0b91
	0aaf 00c2 0e0e lr          $AR2, @0x0e0e
	0ab1 0083 0e44 lri         $AR3, #0x0e44
	0ab3 1c80      mrr         $IX0, $AR0
	0ab4 00c5 0e0f lr          $IX1, @0x0e0f
	0ab6 02bf 8282 call        0x8282
	0ab8 00f8 0bab sr          @0x0bab, $AX0.L
	0aba 00fb 0bae sr          @0x0bae, $AX1.H
	0abc 02df      ret
}

void Unk() {
	0abd 00c0 0e40 lr          $AR0, @0x0e40
	0abf 0081 0b89 lri         $AR1, #0x0b89
	0ac1 00c2 0e08 lr          $AR2, @0x0e08
	0ac3 0083 0e44 lri         $AR3, #0x0e44
	0ac5 00c4 0e41 lr          $IX0, @0x0e41
	0ac7 00c5 0e09 lr          $IX1, @0x0e09
	0ac9 02bf 8282 call        0x8282
	0acb 00f8 0ba9 sr          @0x0ba9, $AX0.L
	0acd 00fb 0bac sr          @0x0bac, $AX1.H
	0acf 00c0 0e43 lr          $AR0, @0x0e43
	0ad1 0081 0b91 lri         $AR1, #0x0b91
	0ad3 00c2 0e0e lr          $AR2, @0x0e0e
	0ad5 0083 0e44 lri         $AR3, #0x0e44
	0ad7 1c80      mrr         $IX0, $AR0
	0ad8 00c5 0e0f lr          $IX1, @0x0e0f
	0ada 02bf 8282 call        0x8282
	0adc 00f8 0bab sr          @0x0bab, $AX0.L
	0ade 00fb 0bae sr          @0x0bae, $AX1.H
	0ae0 00c0 0e40 lr          $AR0, @0x0e40
	0ae2 0081 0b8d lri         $AR1, #0x0b8d
	0ae4 00c2 0e0b lr          $AR2, @0x0e0b
	0ae6 0083 0e44 lri         $AR3, #0x0e44
	0ae8 00c4 0e41 lr          $IX0, @0x0e41
	0aea 00c5 0e0c lr          $IX1, @0x0e0c
	0aec 02bf 8282 call        0x8282
	0aee 00f8 0baa sr          @0x0baa, $AX0.L
	0af0 00fb 0bad sr          @0x0bad, $AX1.H
	0af2 00c0 0e43 lr          $AR0, @0x0e43
	0af4 0081 0b99 lri         $AR1, #0x0b99
	0af6 00c2 0e0d lr          $AR2, @0x0e0d
	0af8 0083 0e44 lri         $AR3, #0x0e44
	0afa 02bf 845d call        0x845d
	0afc 00f8 0bb0 sr          @0x0bb0, $AX0.L
	0afe 02df      ret
}

# Jump table for main commands
0aff 0082   // Jump  0
0b00 013e   // Jump  1
0b01 01bc   // Jump  2
0b02 0248   // Jump  3
0b03 0413   // Jump  4
0b04 0427   // Jump  5
0b05 0165   // Jump  6
0b06 0574   // Jump  7
0b07 0b37   // Jump  8
0b08 015f   // Jump  9
0b09 0478   // Jump  a
0b0a 0474   // Jump  b
0b0b 0476   // Jump  c
0b0c 01a9   // Jump  d
0b0d 043b   // Jump  e
0b0e 047a   // Jump  f Task_Yield()
0b0f 0bb1   // Jump 10
0b10 0175   // Jump 11

# LUT for pb.mixerCtrl
0b11 0768   // Jump3 0
0b12 077a   // Jump3 1
0b13 079d   // Jump3 2
0b14 07c0   // Jump3 3
0b15 07f4   // Jump3 4
0b16 0811   // Jump3 5
0b17 0844   // Jump3 6
0b18 0877   // Jump3 7
0b19 08c6   // Jump3 8
0b1a 08d9   // Jump3 9
0b1b 08fe   // Jump3 a
0b1c 0923   // Jump3 b
0b1d 095a   // Jump3 c
0b1e 0979   // Jump3 d
0b1f 09af   // Jump3 e
0b20 09e5   // Jump3 f

0b21 0a39   // Jump3 10
0b22 0a5b   // Jump3 11
0b23 0768   // Jump3 12
0b24 0768   // Jump3 13
0b25 0768   // Jump3 14
0b26 0768   // Jump3 15
0b27 0768   // Jump3 16
0b28 0768   // Jump3 17
0b29 0a99   // Jump3 18
0b2a 0abd   // Jump3 19
0b2b 0768   // Jump3 1a
0b2c 0768   // Jump3 1b
0b2d 0768   // Jump3 1c
0b2e 0768   // Jump3 1d
0b2f 0768   // Jump3 1e
0b30 0768   // Jump3 1f

# LUT for pb.srcSelect
0b31 05a8   // Jump4 0
0b32 065d   // Jump4 1
0b33 0707   // Jump4 2

# LUT for pb.coefSelect tables (in drom)
0b34 1000
0b35 1200
0b36 1400

# End of noise - back to code.

void Cmd_8() {
	0b37 8e00      set16       
	
	0b38 8100      clr         $ACC0
	0b39 8970      clr'l       $ACC1 : $AC0.M, @$AR0
	0b3a 191c      lrri        $AC0.L, @$AR0
	
	0b3b 2ece      srs         @DSMAH, $AC0.M
	0b3c 2ccf      srs         @DSMAL, $AC0.L
	0b3d 16cd 0e80 si          @DSPA, #0x0e80
	0b3f 16c9 0000 si          @DSCR, #0x0000
	0b41 16cb 0100 si          @DSBL, #0x0100
	
	0b43 1f7e      mrr         $AX1.H, $AC0.M
	0b44 1f3c      mrr         $AX1.L, $AC0.L
	
	0b45 8100      clr         $ACC0
	
	0b46 26c9      lrs         $AC0.M, @DSCR
	0b47 02a0 0004 andf        $AC0.M, #0x0004
	0b49 029c 0b46 jlnz        0x0b46
	
	0b4b 191e      lrri        $AC0.M, @$AR0
	0b4c 191c      lrri        $AC0.L, @$AR0
	0b4d 2ece      srs         @DSMAH, $AC0.M
	0b4e 2ccf      srs         @DSMAL, $AC0.L
	0b4f 16cd 0280 si          @DSPA, #0x0280
	0b51 16c9 0000 si          @DSCR, #0x0000
	0b53 16cb 0280 si          @DSBL, #0x0280
	
	0b55 1c80      mrr         $IX0, $AR0
	
	0b56 0080 0280 lri         $AR0, #0x0280
	0b58 00c1 0e1b lr          $AR1, @0x0e1b
	0b5a 0085 0000 lri         $IX1, #0x0000
	0b5c 0089 007f lri         $WR1, #0x007f
	0b5e 0082 0f00 lri         $AR2, #0x0f00
	0b60 0083 16b4 lri         $AR3, #0x16b4
	0b62 1ce3      mrr         $IX3, $AR3
	0b63 8100      clr         $ACC0
	
	0b64 26c9      lrs         $AC0.M, @DSCR
	0b65 02a0 0004 andf        $AC0.M, #0x0004
	0b67 029c 0b64 jlnz        0x0b64
	
	0b69 8f00      set40       
	0b6a 8a78      m2'l        : $AC1.M, @$AR0
	0b6b 8c68      clr15'l     : $AC1.L, @$AR0
	0b6c f100      lsl16       $ACC1
	0b6d 1a3f      srr         @$AR1, $AC1.M
	0b6e 84e3      clrp'ld     : $AX0.H, $AX1.L, @$AR3
	0b6f 107e      loopi       #0x7e
	0b70 f2e3      madd'ld     $AX0.L, $AX0.H : $AX0.H, $AX1.L, @$AR3
	0b71 f2e7      madd'ldn    $AX0.L, $AX0.H : $AX0.H, $AX1.L, @$AR3
	0b72 f278      madd'l      $AX0.L, $AX0.H : $AC1.M, @$AR0
	0b73 6e68      movp'l      $ACC0 : $AC1.L, @$AR0
	0b74 f132      lsl16's     $ACC1 : @$AR2, $AC0.M
	0b75 1a3f      srr         @$AR1, $AC1.M
	0b76 119e 0b80 bloopi      #0x9e, 0x0b80
		0b78 1c67      mrr         $AR3, $IX3
		0b79 84e3      clrp'ld     : $AX0.H, $AX1.L, @$AR3
		0b7a 107e      loopi       #0x7e
		0b7b f2e3      madd'ld     $AX0.L, $AX0.H : $AX0.H, $AX1.L, @$AR3
		0b7c f2e7      madd'ldn    $AX0.L, $AX0.H : $AX0.H, $AX1.L, @$AR3
		0b7d f278      madd'l      $AX0.L, $AX0.H : $AC1.M, @$AR0
		0b7e 6e68      movp'l      $ACC0 : $AC1.L, @$AR0
		0b7f f132      lsl16's     $ACC1 : @$AR2, $AC0.M
		0b80 1a3f      srr         @$AR1, $AC1.M
		
	0b81 1c67      mrr         $AR3, $IX3
	0b82 84e3      clrp'ld     : $AX0.H, $AX1.L, @$AR3
	0b83 107e      loopi       #0x7e
		0b84 f2e3      madd'ld     $AX0.L, $AX0.H : $AX0.H, $AX1.L, @$AR3
	0b85 f2e7      madd'ldn    $AX0.L, $AX0.H : $AX0.H, $AX1.L, @$AR3
	0b86 f200      madd        $AX0.L, $AX0.H
	0b87 6e00      movp        $ACC0
	0b88 1b5e      srri        @$AR2, $AC0.M
	0b89 00e1 0e1b sr          @0x0e1b, $AR1
	
	0b8b 0080 0280 lri         $AR0, #0x0280
	0b8d 0083 0f00 lri         $AR3, #0x0f00
	0b8f 0081 0000 lri         $AR1, #0x0000
	0b91 0082 0140 lri         $AR2, #0x0140
	0b93 0089 ffff lri         $WR1, #0xffff
	
	0b95 8900      clr         $ACC1
	0b96 8100      clr         $ACC0
	
	0b97 8f00      set40       
	
	0b98 11a0 0ba0 bloopi      #0xa0, 0x0ba0
		0b9a 197f      lrri        $AC1.M, @$AR3
		0b9b 9930      asr16's     $ACC1 : @$AR0, $AC0.M
		0b9c 1b1e      srri        @$AR0, $AC0.M
		0b9d 1b3f      srri        @$AR1, $AC1.M
		0b9e 7d29      neg's       $ACC1 : @$AR1, $AC1.L
		0b9f 1b5f      srri        @$AR2, $AC1.M
		0ba0 1b5d      srri        @$AR2, $AC1.L
		
	0ba1 8e00      set16       
	
	0ba2 1fdb      mrr         $AC0.M, $AX1.H
	0ba3 1f99      mrr         $AC0.L, $AX1.L
	0ba4 2ece      srs         @DSMAH, $AC0.M
	0ba5 2ccf      srs         @DSMAL, $AC0.L
	0ba6 16cd 0e80 si          @DSPA, #0x0e80
	0ba8 16c9 0001 si          @DSCR, #0x0001
	0baa 16cb 0100 si          @DSBL, #0x0100
	
	// 0bac 02bf 055c call        0x055c
	WaitDMA();
	
	0bae 1c04      mrr         $AR0, $IX0
	
	// 0baf 029f 0068 jmp         0x0068
	goto DoNextCommand;
}

void Cmd_10() {
	0bb1 8e00      set16       
	
	0bb2 8100      clr         $ACC0
	0bb3 8970      clr'l       $ACC1 : $AC0.M, @$AR0
	0bb4 191c      lrri        $AC0.L, @$AR0
	
	0bb5 2ece      srs         @DSMAH, $AC0.M
	0bb6 2ccf      srs         @DSMAL, $AC0.L
	0bb7 16cd 07c0 si          @DSPA, #0x07c0
	0bb9 16c9 0001 si          @DSCR, #0x0001
	0bbb 16cb 0500 si          @DSBL, #0x0500
	
	// 0bbd 02bf 055c call        0x055c
	WaitDMA();
	
	0bbf 8100      clr         $ACC0
	0bc0 8970      clr'l       $ACC1 : $AC0.M, @$AR0
	0bc1 191c      lrri        $AC0.L, @$AR0
	
	0bc2 2ece      srs         @DSMAH, $AC0.M
	0bc3 2ccf      srs         @DSMAL, $AC0.L
	0bc4 16cd 07c0 si          @DSPA, #0x07c0
	0bc6 16c9 0000 si          @DSCR, #0x0000
	0bc8 8900      clr         $ACC1
	0bc9 0d20      lris        $AC1.L, #0x20
	0bca 2dcb      srs         @DSBL, $AC1.L
	
	0bcb 4c00      add         $ACC0, $ACC1
	
	0bcc 1c80      mrr         $IX0, $AR0
	
	0bcd 0080 07c0 lri         $AR0, #0x07c0
	0bcf 0083 0000 lri         $AR3, #0x0000
	0bd1 1c43      mrr         $AR2, $AR3
	0bd2 0a00      lris        $AX0.H, #0x00
	
	0bd3 27c9      lrs         $AC1.M, @DSCR
	0bd4 03a0 0004 andf        $AC1.M, #0x0004
	0bd6 029c 0bd3 jlnz        0x0bd3
	
	0bd8 2ece      srs         @DSMAH, $AC0.M
	0bd9 2ccf      srs         @DSMAL, $AC0.L
	0bda 16cd 07d0 si          @DSPA, #0x07d0
	0bdc 16c9 0000 si          @DSCR, #0x0000
	0bde 16cb 04e0 si          @DSBL, #0x04e0
	
	0be0 8f00      set40       
	
	0be1 80f0      nx'ld       : $AX0.H, $AX1.H, @$AR0
	0be2 80c0      nx'ld       : $AX0.L, $AX1.L, @$AR0
	0be3 6a00      movax       $ACC0, $AX1
	0be4 4800      addax       $ACC0, $AX0
	0be5 114f 0bee bloopi      #0x4f, 0x0bee
		0be7 80f0      nx'ld       : $AX0.H, $AX1.H, @$AR0
		0be8 80c0      nx'ld       : $AX0.L, $AX1.L, @$AR0
		0be9 6b32      movax's     $ACC1, $AX1.L : @$AR2, $AC0.M
		0bea 4922      addax's     $ACC1, $AX0.L : @$AR2, $AC0.L
		0beb 80f0      nx'ld       : $AX0.H, $AX1.H, @$AR0
		0bec 80c0      nx'ld       : $AX0.L, $AX1.L, @$AR0
		0bed 6a3a      movax's     $ACC0, $AX1.L : @$AR2, $AC1.M
		0bee 482a      addax's     $ACC0, $AX0.L : @$AR2, $AC1.L
		
	0bef 80f0      nx'ld       : $AX0.H, $AX1.H, @$AR0
	0bf0 80c0      nx'ld       : $AX0.L, $AX1.L, @$AR0
	0bf1 6b32      movax's     $ACC1, $AX1.L : @$AR2, $AC0.M
	0bf2 4922      addax's     $ACC1, $AX0.L : @$AR2, $AC0.L
	0bf3 1b5f      srri        @$AR2, $AC1.M
	0bf4 1b5d      srri        @$AR2, $AC1.L
	0bf5 80f0      nx'ld       : $AX0.H, $AX1.H, @$AR0
	0bf6 80c0      nx'ld       : $AX0.L, $AX1.L, @$AR0
	0bf7 6800      movax       $ACC0, $AX0
	0bf8 7c00      neg         $ACC0
	0bf9 4a00      addax       $ACC0, $AX1
	0bfa 114f 0c05 bloopi      #0x4f, 0x0c05
		0bfc 80f0      nx'ld       : $AX0.H, $AX1.H, @$AR0
		0bfd 80c0      nx'ld       : $AX0.L, $AX1.L, @$AR0
		0bfe 6932      movax's     $ACC1, $AX0.L : @$AR2, $AC0.M
		0bff 7d00      neg         $ACC1
		0c00 4b22      addax's     $ACC1, $AX1.L : @$AR2, $AC0.L
		0c01 80f0      nx'ld       : $AX0.H, $AX1.H, @$AR0
		0c02 80c0      nx'ld       : $AX0.L, $AX1.L, @$AR0
		0c03 683a      movax's     $ACC0, $AX0.L : @$AR2, $AC1.M
		0c04 7c00      neg         $ACC0
		0c05 4a2a      addax's     $ACC0, $AX1.L : @$AR2, $AC1.L
		
	0c06 80f0      nx'ld       : $AX0.H, $AX1.H, @$AR0
	0c07 80c0      nx'ld       : $AX0.L, $AX1.L, @$AR0
	0c08 6932      movax's     $ACC1, $AX0.L : @$AR2, $AC0.M
	0c09 7d00      neg         $ACC1
	0c0a 4b22      addax's     $ACC1, $AX1.L : @$AR2, $AC0.L
	0c0b 1b5f      srri        @$AR2, $AC1.M
	0c0c 1b5d      srri        @$AR2, $AC1.L
	
	0c0d 1c04      mrr         $AR0, $IX0
	
	// 0c0e 029f 0068 jmp         0x0068
	goto DoNextCommand;
}

# Begin interrupt handlers

// Sends mail with value on top of callstack and rti's
void ResetAndStackUOFlow_Handler() {
	0c10 8e00      set16       
	
	// 0c11 16fc ecc0 si          @DMBH, #0xecc0
	// 0c13 1fcc      mrr         $AC0.M, $ST0
	// 0c14 1d9e      mrr         $ST0, $AC0.M
	// 0c15 2efd      srs         @DMBL, $AC0.M
	DMB = 0xecc00000 | $ST0
	
	// 0c16 26fc      lrs         $AC0.M, @DMBH
	// 0c17 02a0 8000 andf        $AC0.M, #0x8000
	// 0c19 029c 0c16 jlnz        0x0c16
	while (@DMBH & 0x8000 == 0);
	
	// 0c1b 0000      nop         
	// 0c1c 0000      nop         
	// 0c1d 0000      nop         
	// 0c1e 02ff      rti         
	return;
}

// Saves/Restores whole ACC0, but only modifies AC0.M. strange
void Int2_Handler() {
	0c1f 8e00      set16       
	
	// Save ACC0
	0c20 00f0 0e17 sr          @0x0e17, $AC0.H
	0c22 00fe 0e18 sr          @0x0e18, $AC0.M
	0c24 00fc 0e19 sr          @0x0e19, $AC0.L
	
	// 0c26 1fcc      mrr         $AC0.M, $ST0
	// 0c27 1d9e      mrr         $ST0, $AC0.M
	// 0c28 16fc feed si          @DMBH, #0xfeed
	// 0c2a 2efd      srs         @DMBL, $AC0.M
	DMB = 0xfeed0000 | $ST0
	
	// 0c2b 26fc      lrs         $AC0.M, @DMBH
	// 0c2c 02a0 8000 andf        $AC0.M, #0x8000
	// 0c2e 029c 0c2b jlnz        0x0c2b
	while (@DMBH & 0x8000 == 0);
	
	// Restore ACC0
	0c30 00d0 0e17 lr          $AC0.H, @0x0e17
	0c32 00de 0e18 lr          $AC0.M, @0x0e18
	0c34 00dc 0e19 lr          $AC0.L, @0x0e19
	
	// 0c36 0000      nop         
	// 0c37 0000      nop         
	// 0c38 0000      nop         
	// 0c39 0000      nop         
	// 0c3a 02ff      rti         
	return;
}

void Int3_Handler() {
	0c3b 8e00      set16       
	
	// Save AC0.L, AC0.M
	0c3c 1dbc      mrr         $ST1, $AC0.L
	0c3d 1dbe      mrr         $ST1, $AC0.M
	
	// 0c3e 8100      clr         $ACC0
	// 0c3f 00de 0bb7 lr          $AC0.M, @0x0bb7
	// 0c41 0601      cmpis       $AC0.M, #0x01
	// 0c42 0295 0c47 jz          0x0c47
	// 0c44 0e00      lris        $AC0.M, #0x00
	// 0c45 00fe 0b87 sr          @0x0b87, $AC0.M
	if (*0x0bb7 != 1) {	// pb.addr != AXPBADDR_LOOP_ON
		*0x0b87 = 0;	// pb.state = AX_PB_STATE_STOP
	}
	
	// Restore AC0.L, AC0.M
	0c47 1fcd      mrr         $AC0.M, $ST1
	0c48 1f8d      mrr         $AC0.L, $ST1
	
	// 0c49 02ff      rti         
	return;
}

void Int4_Handler() {
	// 0c4a 0000      nop         
	// 0c4b 0000      nop         
	// 0c4c 0000      nop         
	// 0c4d 0000      nop         
	// 0c4e 0000      nop         
	// 0c4f 02ff      rti         
	return;
}

void Int5_Handler() {
	0c50 8e00      set16       
	
	// Save AC0.L, AC0.M
	0c51 1dbc      mrr         $ST1, $AC0.L
	0c52 1dbe      mrr         $ST1, $AC0.M
	
	// 0c53 8100      clr         $ACC0
	// 0c54 00de 0bb7 lr          $AC0.M, @0x0bb7
	// 0c56 0601      cmpis       $AC0.M, #0x01
	// 0c57 0295 0c5f jz          0x0c5f
	if (*0x0bb7 != 1)	// pb.addr != AXPBADDR_LOOP_ON
	{
		// 0c59 0e00      lris        $AC0.M, #0x00
		// 0c5a 00fe 0b87 sr          @0x0b87, $AC0.M
		*0x0b87 = 0;	// pb.state = AX_PB_STATE_STOP
		
		// Restore AC0.L, AC0.M
		0c5c 1fcd      mrr         $AC0.M, $ST1
		0c5d 1f8d      mrr         $AC0.L, $ST1
		
		// 0c5e 02ff      rti         
		return;
	}

	// 0c5f 8100      clr         $ACC0
	// 0c60 00de 0b88 lr          $AC0.M, @0x0b88
	// 0c62 0601      cmpis       $AC0.M, #0x01
	// 0c63 0295 0c71 jz          0x0c71
	if (*0x0b88 != 1) { // pb.type != AX_PB_TYPE_STREAM
	
		// 0c65 00de 0bda lr          $AC0.M, @0x0bda
		// 0c67 2eda      srs         @scale, $AC0.M
		// 0c68 00de 0bdb lr          $AC0.M, @0x0bdb
		// 0c6a 2edb      srs         @yn1, $AC0.M
		// 0c6b 00de 0bdc lr          $AC0.M, @0x0bdc
		// 0c6d 2edc      srs         @yn2, $AC0.M
		@scale = pb.adpcmLoop.loop_pred_scale
		@yn1 = pb.adpcmLoop.loop_yn1
		@yn2 = pb.adpcmLoop.loop_yn2
		
		// Restore AC0.L, AC0.M
		0c6e 1fcd      mrr         $AC0.M, $ST1
		0c6f 1f8d      mrr         $AC0.L, $ST1
		
		// 0c70 02ff      rti         
		return;
		
	} else {
	
		// 0c71 00de 0bda lr          $AC0.M, @0x0bda
		// 0c73 2eda      srs         @scale, $AC0.M
		// 0c74 26db      lrs         $AC0.M, @yn1
		// 0c75 2edb      srs         @yn1, $AC0.M
		// 0c76 26dc      lrs         $AC0.M, @yn2
		// 0c77 2edc      srs         @yn2, $AC0.M
		@scale = pb.adpcmLoop.loop_pred_scale
		// refresh @yn1, @yn2....why?
		@yn1 = @yn1
		@yn2 = @yn2
		
		// Well helllloooo there, padding
		// 0c78 8100      clr         $ACC0
		// 0c79 00dc 0bdd lr          $AC0.L, @0x0bdd
		// 0c7b 7600      inc         $ACC0
		// 0c7c 00fc 0bdd sr          @0x0bdd, $AC0.L
		// 0c7e 8100      clr         $ACC0
		pb.pad[0]++
		
		// Restore AC0.L, AC0.M
		0c7f 1fcd      mrr         $AC0.M, $ST1
		0c80 1f8d      mrr         $AC0.L, $ST1
		
		// 0c81 02ff      rti         
		return;
	}
}

void Int6_Handler() {
	0c82 0000      nop         
	0c83 0000      nop         
	0c84 0000      nop         
	0c85 0000      nop         
	0c86 0000      nop         
	0c87 02ff      rti         
}

void Int7_Handler() {
	0c88 0000      nop         
	0c89 0000      nop         
	0c8a 0000      nop         
	0c8b 0000      nop         
	0c8c 02ff      rti         
}

# End of interrupt handlers

// Jump table for the next function.
0c8d 0c9f	// some kind of soft-reset for the UCode
0c8e 0ca2	// looks like code to dump the UCode memory for debugging
0c8f 0cda	// rest the UCode and jump to ROM
0c90 0cdd	// normal case to return to the main-loop

// Called only from Task_Yield()
// Decides what to do next (this cmdblock is done)
void JumpThroughTable2() {
	0c91 8e00      set16       
	0c92 8100      clr         $ACC0
	0c93 8900      clr         $ACC1
	
	// 0c94 02bf 0ce0 call        0x0ce0
	WaitForCPUMail0();
	
	// 0c96 27ff      lrs         $AC1.M, @CMBL
	// 0c97 009e 0c8d lri         $AC0.M, #0x0c8d
	// 0c99 4c00      add         $ACC0, $ACC1
	// 0c9a 1c7e      mrr         $AR3, $AC0.M
	// 0c9b 0313      ilrr        $AC1.M, @$AR3
	// 0c9c 1c7f      mrr         $AR3, $AC1.M
	// 0c9d 176f      jmpr        $AR3
	switch(@CMBL) {
	case 0: AX_ResumeTask(); break;
	case 1: JumpTable2_1(); break;
	case 2: IROM_Reset(); break;
	case 3: AX_GetNextCmdBlock(); break;
	}
	0c9e 0021      halt        
}

// case 0:
void AX_ResumeTask() {
	0c9f 029f 0030 jmp         0x0030
	0ca1 0021      halt        
}

// case 1:
// funky...calls the mbox funcs, sometimes prefilling ACx regs...
// Perhaps DMAs some stuff and yields?
// Need to RE the ROM to figure this func out completely
void JumpTable2_1() {
	// 0ca2 8100      clr         $ACC0
	// 0ca3 8900      clr         $ACC1
	// 0ca4 02bf 0ce0 call        0x0ce0
	WaitForCPUMail0();
	
	// 0ca6 24ff      lrs         $AC0.L, @CMBL
	// 0ca7 02bf 0ce6 call        0x0ce6
	WaitForCPUMail1();
	
	// 0ca9 25ff      lrs         $AC1.L, @CMBL
	// 0caa 02bf 0ce6 call        0x0ce6
	WaitForCPUMail1();
	
	0cac 27ff      lrs         $AC1.M, @CMBL
	0cad 2ece      srs         @DSMAH, $AC0.M
	0cae 2ccf      srs         @DSMAL, $AC0.L
	0caf 16c9 0001 si          @DSCR, #0x0001
	0cb1 2fcd      srs         @DSPA, $AC1.M
	0cb2 2dcb      srs         @DSBL, $AC1.L
	
	// 0cb3 8100      clr         $ACC0
	// 0cb4 8900      clr         $ACC1
	// 0cb5 02bf 0ce0 call        0x0ce0
	WaitForCPUMail0();
	
	0cb7 24ff      lrs         $AC0.L, @CMBL
	0cb8 1c9e      mrr         $IX0, $AC0.M
	0cb9 1cbc      mrr         $IX1, $AC0.L
	0cba 02bf 0ce6 call        0x0ce6
	WaitForCPUMail1();
	
	0cbc 25ff      lrs         $AC1.L, @CMBL
	0cbd 02bf 0ce6 call        0x0ce6
	WaitForCPUMail1();
	
	0cbf 27ff      lrs         $AC1.M, @CMBL
	0cc0 1cdf      mrr         $IX2, $AC1.M
	0cc1 1cfd      mrr         $IX3, $AC1.L
	
	// 0cc2 8100      clr         $ACC0
	// 0cc3 02bf 0ce0 call        0x0ce0
	WaitForCPUMail0();
	
	0cc5 26ff      lrs         $AC0.M, @CMBL
	0cc6 1c1e      mrr         $AR0, $AC0.M
	0cc7 8900      clr         $ACC1
	0cc8 02bf 0ce6 call        0x0ce6
	WaitForCPUMail1();
	
	0cca 20ff      lrs         $AX0.L, @CMBL
	0ccb 1f5f      mrr         $AX0.H, $AC1.M
	0ccc 02bf 0ce0 call        0x0ce0
	WaitForCPUMail0();
	
	0cce 21ff      lrs         $AX1.L, @CMBL
	0ccf 02bf 0ce0 call        0x0ce0
	WaitForCPUMail0();
	
	0cd1 23ff      lrs         $AX1.H, @CMBL
	
	// 0cd2 26c9      lrs         $AC0.M, @DSCR
	// 0cd3 02a0 0004 andf        $AC0.M, #0x0004
	// 0cd5 029c 0cd2 jlnz        0x0cd2
	while (@DSCR & 0x0004 != 0); // Wait for DMA to complete
	
	// 0cd7 029f 80b5 jmp         0x80b5
	// 0cd9 0021      halt        
	IROM_ErrorAndDie(); // Not sure...gotta RE the ROM
}

// case 2:
void IROM_Reset() {
	0cda 029f 8000 jmp         0x8000
	0cdc 0021      halt        
}

// case 3:
void AX_GetNextCmdBlock() {
	// 0cdd 029f 0045 jmp         0x0045
	goto GetNextCmdBlock;
	
	0cdf 0021      halt        
}

void WaitForCPUMail0() {
	// 0ce0 26fe      lrs         $AC0.M, @CMBH
	// 0ce1 02c0 8000 andcf       $AC0.M, #0x8000
	// 0ce3 029c 0ce0 jlnz        0x0ce0
	while (@CMBH & 0x8000 == 0);
	// 0ce5 02df      ret
	return;
}

void WaitForCPUMail1() {
	// 0ce6 27fe      lrs         $AC1.M, @CMBH
	// 0ce7 03c0 8000 andcf       $AC1.M, #0x8000
	// 0ce9 029c 0ce6 jlnz        0x0ce6
	while (@CMBH & 0x8000 == 0);
	// 0ceb 02df      ret
	return;
}

0cec 0000      nop         
0ced 0000      nop         
0cee 0000      nop         
0cef 0000      nop         
